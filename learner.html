<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learner</title>
    <link rel="icon" type="image/png" href="https://i.imgur.com/nXRkDYO.png">
    <link rel="apple-touch-icon" href="https://i.imgur.com/nXRkDYO.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Learner">
    <link rel="manifest" href="./manifest.json">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --font-scale: 1;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            font-size: calc(16px * var(--font-scale));
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        header p {
            font-size: calc(1.1rem * var(--font-scale));
            opacity: 0.9;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: calc(1.1rem * var(--font-scale));
            color: #666;
        }

        .error {
            background-color: #fee;
            border: 1px solid #fcc;
            color: #c33;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .blog-post {
            background: white;
            margin-bottom: 15px;
            border-radius: 12px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        body.dark-mode .blog-post {
            background: #1a1a1a;
            border: 1px solid #444;
        }

        .blog-post:hover:not(.read) {
            transform: translateY(-2px);
            box-shadow: 0 4px 25px rgba(0,0,0,0.12);
        }

        .blog-post.read {
            opacity: 0.5;
        }

        .blog-post.audio-not-ready {
            border: 1px solid #6e6e6e;
        }

        .blog-post.collapsed .post-content {
            display: none;
        }

        .blog-post.collapsed .mark-read-btn {
            margin-top: 0;
        }

        .mark-read-btn-bottom {
            background: #071df5;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: calc(0.9rem * var(--font-scale));
            cursor: pointer;
            margin-top: 20px;
            opacity: 0.8;
            transition: background-color 0.2s ease;
            display: block;
            margin-left: auto;
        }

        .mark-read-btn-bottom:hover { background: #071df5; }
        .mark-read-btn-bottom.read { background: #28a745; }
        .mark-read-btn-bottom.read:hover { background: #218838; }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            background-color: #f8f9fa;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            background: #071df5;
            padding: 15px 20px;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.8);
            width: 0%;
            transition: width 0.1s ease-out;
        }

        .header-title {
            font-size: calc(1.2rem * var(--font-scale));
            font-weight: 100;
            color: white;
            margin: 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .header-menu {
            background: transparent;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-menu svg { stroke-width: 1.5; }
        .header-menu:hover { background: rgba(255, 255, 255, 0.1); }

        /* Header audio control */
        .header-audio-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .header-audio-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .header-audio-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .header-audio-btn.playing {
            background: rgba(255, 255, 255, 0.25);
        }

        /* Add top padding to body to account for fixed header */
        body {
            padding-top: 70px;
        }

        .post-header {
            position: sticky;
            top: 0;
            z-index: 98;
        }

        .highlight {
            background-color: #fff3cd;
            border-radius: 2px;
            padding: 1px 2px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .highlight:hover { background-color: #ffeaa7; }
        .highlight-tooltip {
            position: absolute; background: #333; color: white; padding: 8px 12px;
            border-radius: 4px; font-size: calc(0.8rem * var(--font-scale));
            cursor: pointer; z-index: 1000; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            user-select: none;
        }
        .highlight-tooltip:hover { background: #071df5; }

        .highlight-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .highlight-tooltip:hover::after {
            border-color: #071df5 transparent transparent transparent;
        }

        .sync-btn {
            background: #071df5;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: calc(0.9rem * var(--font-scale));
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            font-weight: 100;
        }

        .sync-btn:hover {
            background: #0516cc;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(7, 29, 245, 0.2);
        }

        .sync-btn:active {
            transform: translateY(0);
        }

        .sync-btn.syncing {
            background: #3b82f6;
            cursor: wait;
        }

        .collapse-all-btn {
            background: #071df5; color: white; border: none; padding: 10px 12px;
            border-radius: 4px; font-size: calc(0.8rem * var(--font-scale));
            cursor: pointer; transition: background-color 0.2s ease;
            white-space: nowrap; display: flex; align-items: center;
            justify-content: center;
        }
        .collapse-all-btn { opacity: 0.8; }
        .collapse-all-btn:hover, .sync-btn:hover { background: #071df5; }

        /* Hamburger Menu Sidebar */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .menu-overlay.active { opacity: 1; visibility: visible; }
        .menu-sidebar {
            position: fixed; top: 0; left: -300px; width: 300px; height: 100%;
            background: white; z-index: 1001; transition: left 0.3s ease;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1); padding: 20px;
        }
        .menu-sidebar.active { left: 0; }

        .menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .menu-title {
            font-size: calc(1.2rem * var(--font-scale));
            font-weight: 100;
            color: #333;
        }

        .menu-close {
            background: none;
            border: none;
            font-size: calc(1.5rem * var(--font-scale));
            cursor: pointer;
            color: #666;
            padding: 5px;
        }

        .menu-close:hover {
            color: #333;
        }

        .menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 0;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
        }

        .menu-item:hover {
            background: #f8f9fa;
            margin: 0 -20px;
            padding-left: 20px;
            padding-right: 20px;
        }

        .menu-item-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: calc(0.9rem * var(--font-scale));
            color: #333;
        }

        .theme-toggle {
            position: relative;
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .theme-toggle.dark {
            background: #071df5;
        }

        .theme-toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        .theme-toggle.dark .theme-toggle-slider {
            transform: translateX(26px);
        }

        /* Font size controls */
        .font-size-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .font-size-btn {
            background: #071df5;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: calc(0.8rem * var(--font-scale));
            cursor: pointer;
            transition: background-color 0.2s ease;
            min-width: 28px;
            opacity: 0.8;
        }

        .font-size-btn:hover { background: #071df5; opacity: 1; }
        .font-size-display {
            font-size: calc(0.9rem * var(--font-scale)); color: #666;
            min-width: 40px; text-align: center;
        }
        body.dark-mode .font-size-display { color: #999; }

        .playback-speed-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .playback-speed-btn {
            background: #071df5;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: calc(0.8rem * var(--font-scale));
            cursor: pointer;
            transition: background-color 0.2s ease;
            min-width: 28px;
            opacity: 0.8;
        }

        .playback-speed-btn:hover { background: #071df5; opacity: 1; }
        .playback-speed-display {
            font-size: calc(0.9rem * var(--font-scale)); color: #666;
            min-width: 40px; text-align: center;
        }
        body.dark-mode .playback-speed-display { color: #999; }

        /* Dark mode styles */
        body.dark-mode {
            background: #1a1a1a;
            color: #e0e0e0;
        }

        body.dark-mode .container {
            background: #1a1a1a;
        }

        body.dark-mode .controls {
            background: #1e1e1e;
        }

        body.dark-mode .search-bar {
            background: #1A1A1A;
            border: 1px solid #555;
            color: #e0e0e0;
        }

        body.dark-mode .search-bar::placeholder { color: #999; }
        body.dark-mode .post-header { border-bottom: 1px solid #444; }
        body.dark-mode .post-header:hover { background: #1A1A1A; }
        body.dark-mode .post-title a { color: #6a78f8; }
        body.dark-mode .post-date { color: #999; }
        body.dark-mode .post-content { color: #e0e0e0; }

        body.dark-mode .post-content h1,
        body.dark-mode .post-content h2,
        body.dark-mode .post-content h3,
        body.dark-mode .post-content h4,
        body.dark-mode .post-content h5,
        body.dark-mode .post-content h6 {
            color: #6a78f8;
            font-weight: 300;
        }

        body.dark-mode .post-content h1 { font-size: calc(1.4rem * var(--font-scale)); }
        body.dark-mode .post-content h2 { font-size: calc(1.2rem * var(--font-scale)); }
        body.dark-mode .post-content h3, body.dark-mode .post-content h4,
        body.dark-mode .post-content h5, body.dark-mode .post-content h6 { font-size: calc(1.0rem * var(--font-scale)); }

        body.dark-mode .post-content table {
            border: 0.1px solid #2f2f2f;
            border-radius: 8px;
            overflow: hidden;
        }

        body.dark-mode .post-content table th,
        body.dark-mode .post-content table td {
            border: 0.1px solid #2f2f2f;
            background: transparent;
        }

        body.dark-mode .post-content table th {
            font-weight: 100;
        }

        body.dark-mode .post-content th:first-child,
        body.dark-mode .post-content td:first-child {
            min-width: 75px;
        }

        body.dark-mode .post-content p {
            color: #e0e0e0;
        }

        body.dark-mode .post-content ul li::before {
            border-right-color: #6a78f8;
            border-bottom-color: #6a78f8;
            opacity: 0.5;
        }

        body.dark-mode .menu-sidebar {
            background: #2d2d2d;
        }

        body.dark-mode .menu-title {
            color: #e0e0e0;
        }

        body.dark-mode .menu-close {
            color: #999;
        }

        .mark-read-btn-bottom:hover {
            background: #e0e0e0;
        }

        body.dark-mode .mark-read-btn-bottom:hover {
            background: #555;
        }

        body.dark-mode .menu-close:hover {
            color: #e0e0e0;
        }

        /* YouTube embed styling with 16:9 aspect ratio */
        .youtube-embed-container {
            margin: 10px 0 5px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 56.25%; /* 16:9 aspect ratio (9/16 = 0.5625) */
        }

        body.dark-mode .youtube-embed-container {
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* Text tracking highlight for audio playback */
        .speech-tracking-segment {
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            border-radius: 4px;
            padding: 2px 0;
        }

        .speech-tracking-segment.current-speech {
            background-color: rgba(106, 120, 248, 0.15);
            box-shadow: -4px 0 0 rgba(106, 120, 248, 0.5);
        }

        body.dark-mode .speech-tracking-segment.current-speech {
            background-color: rgba(106, 120, 248, 0.25);
            box-shadow: -4px 0 0 rgba(106, 120, 248, 0.7);
        }

        .youtube-embed-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        /* YouTube fallback styling */
        .youtube-fallback {
            position: relative;
            width: 100%;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }

        .youtube-thumbnail-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }

        .youtube-thumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.8;
        }

        .youtube-play-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0.9;
        }

        .youtube-fallback-link {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            text-decoration: none;
            font-weight: bold;
            font-size: 18px;
            background: rgba(0,0,0,0.3);
            transition: background 0.3s ease;
        }

        .youtube-fallback-link:hover {
            background: rgba(0,0,0,0.5);
            color: white;
            text-decoration: none;
        }

        body.dark-mode .menu-item-label {
            color: #e0e0e0;
        }

        body.dark-mode .menu-header {
            border-bottom: 1px solid #444;
        }

        body.dark-mode .menu-item {
            border-bottom: 1px solid #444;
        }

        body.dark-mode .menu-item:hover {
            background: #3d3d3d;
        }

        /* API Key Modal Styles */
        .api-key-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .api-key-modal.show {
            display: flex;
        }

        .api-key-modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        body.dark-mode .api-key-modal-content {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        .api-key-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        body.dark-mode .api-key-modal-header {
            border-bottom: 1px solid #444;
        }

        .api-key-modal-title {
            font-size: calc(1.2rem * var(--font-scale));
            font-weight: 100;
            color: #333;
        }

        body.dark-mode .api-key-modal-title {
            color: #e0e0e0;
        }

        .api-key-modal-close {
            background: none;
            border: none;
            font-size: calc(1.5rem * var(--font-scale));
            cursor: pointer;
            color: #666;
            padding: 5px;
        }

        body.dark-mode .api-key-modal-close {
            color: #999;
        }

        .api-key-modal-close:hover {
            color: #333;
        }

        body.dark-mode .api-key-modal-close:hover {
            color: #e0e0e0;
        }

        .api-key-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .api-key-input {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: calc(0.9rem * var(--font-scale));
            transition: border-color 0.2s ease;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        body.dark-mode .api-key-input {
            background: #1a1a1a;
            border: 1px solid #555;
            color: #e0e0e0;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #0d47a1;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .input-group {
            display: flex;
            gap: 8px;
            align-items: center;
            width: 100%;
        }

        .copy-btn {
            background: none;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 0;
            cursor: pointer;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            height: 42px;
            width: 42px;
            flex-shrink: 0;
        }

        body.dark-mode .copy-btn {
            border-color: #555;
            color: #aaa;
        }

        .copy-btn:hover {
            background: #f0f0f0;
            color: #333;
        }

        body.dark-mode .copy-btn:hover {
            background: #2a2a2a;
            color: #fff;
        }

        .api-key-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .api-key-btn {
            background: #071df5;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: calc(0.9rem * var(--font-scale));
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .api-key-btn:hover {
            background: #071df5;
        }

        .api-key-btn.secondary {
            background: #6c757d;
        }

        .api-key-btn.secondary:hover {
            background: #5a6268;
        }

        .api-key-help {
            font-size: calc(0.8rem * var(--font-scale));
            color: #666;
            line-height: 1.4;
            margin-bottom: 15px;
        }

        body.dark-mode .api-key-help {
            color: #999;
        }

        .audio-status {
            font-size: calc(0.6rem * var(--font-scale));
            margin-left: 8px;
            padding: 5px 10px;
            border-radius: 20px;
            font-weight: 800;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            vertical-align: middle;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            line-height: 1;
            height: fit-content;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid transparent;
        }

        .audio-status.downloaded {
            color: #10b981;
            background: rgba(16, 185, 129, 0.08);
            border-color: rgba(16, 185, 129, 0.2);
        }

        .audio-status.todo {
            color: #6b7280;
            background: rgba(107, 114, 128, 0.08);
            border-color: rgba(107, 114, 128, 0.2);
        }

        .audio-status.syncing {
            color: #3b82f6;
            background: rgba(59, 130, 246, 0.08);
            border-color: rgba(59, 130, 246, 0.3);
            animation: pulse-sync 1.5s infinite ease-in-out;
        }

        @keyframes pulse-sync {
            0% { opacity: 0.7; transform: scale(0.97); }
            50% { opacity: 1; transform: scale(1); }
            100% { opacity: 0.7; transform: scale(0.97); }
        }

        body.dark-mode .audio-status.downloaded {
            color: #34d399;
            background: rgba(52, 211, 153, 0.12);
            border-color: rgba(52, 211, 153, 0.2);
        }
        body.dark-mode .audio-status.todo {
            color: #9ca3af;
            background: rgba(156, 163, 175, 0.12);
            border-color: rgba(156, 163, 175, 0.2);
        }
        body.dark-mode .audio-status.syncing {
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.12);
            border-color: rgba(96, 165, 250, 0.3);
        }

        .api-key-help a {
            color: #071df5;
            text-decoration: none;
        }

        .api-key-help a:hover {
            text-decoration: underline;
        }

        /* API Key Status Indicator */
        .api-key-status {
            opacity: 0;
            color: #28a745;
            transition: opacity 0.3s ease;
            display: flex;
            align-items: center;
        }

        .api-key-status.configured {
            opacity: 1;
        }

        body.dark-mode .api-key-status {
            color: #28a745;
        }

        .settings-section-title {
            font-size: 0.9rem;
            font-weight: 500;
            margin: 20px 0 10px;
            color: #071df5;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        body.dark-mode .settings-section-title {
            color: #6a78f8;
            border-bottom-color: #444;
        }

        .bulk-config-container {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px dashed #eee;
        }

        body.dark-mode .bulk-config-container {
            border-top-color: #444;
        }

        .bulk-config-textarea {
            width: 100%;
            height: 120px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.75rem;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
            resize: vertical;
            line-height: 1.4;
        }

        body.dark-mode .bulk-config-textarea {
            background: #1a1a1a;
            color: #e0e0e0;
            border-color: #555;
        }

        .input-label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.8rem;
            font-weight: 500;
            color: #666;
        }

        body.dark-mode .input-label {
            color: #aaa;
        }

        .listen-btn {
            background: #071df5;
            color: white;
            border: none;
            padding: 6px;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            width: 32px;
            height: 32px;
            flex-shrink: 0;
        }

        .listen-btn:hover {
            background: #071df5;
        }

        .listen-btn.playing {
            background: #071df5;
        }

        .listen-btn.playing:hover {
            background: #071df5;
        }

        .listen-btn.loading {
            background: #071df5;
            opacity: 0.8;
        }

        .listen-btn.loading:hover {
            background: #071df5;
        }

        .listen-btn.paused {
            background: #071df5;
            opacity: 0.7;
        }

        .listen-btn.paused:hover {
            background: #071df5;
        }

        .post-header {
            padding: 25px 30px 20px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s ease;
            position: relative;
        }

        .post-header:hover {
            background-color: #f8f9fa;
        }

        body.dark-mode .post-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        body.dark-mode .post-header:hover {
            background-color: #1a1a1a;
        }


        .post-title {
            font-size: calc(1.8rem * var(--font-scale));
            font-weight: 300;
            margin-bottom: 10px;
            color: #6a78f8;
            line-height: 1.3;
        }

        .post-title-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .floating-nav {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 80px;
            display: flex;
            align-items: center;
            gap: 20px;
            background: transparent;
            padding: 0;
            opacity: 0.7;
            pointer-events: auto;
            transition: opacity 0.2s ease, transform 0.2s ease, bottom 0.3s ease;
            z-index: 900;
        }

        .floating-nav.visible {
            opacity: 0.9;
            pointer-events: auto;
            transform: translateX(-50%) translateY(0);
        }

        .floating-nav.tabs-visible {
            bottom: 80px;
        }

        .floating-nav button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #384af5;
            background: rgba(20, 25, 45, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #384af5;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
        }

        .floating-nav button:hover {
            background: rgba(30, 40, 70, 0.9);
            transform: translateY(-1px);
        }

        .floating-nav button svg {
            width: 30px;
            height: 30px;
            pointer-events: none;
            stroke: currentColor;
        }

        .floating-nav button.mark-action {
            background: #384af5;
            color: #ffffff;
            border-color: #384af5;
        }

        .floating-nav button.mark-action:hover {
            background: #2a3cd4;
            border-color: #2a3cd4;
        }





        .post-title a {
            color: inherit;
            text-decoration: none;
            transition: color 0.2s ease;
            color: #6a78f8;
        }

        .post-title a:hover {
            color: #6a78f8;
        }

        .post-date {
            color: #666;
            font-size: calc(0.9rem * var(--font-scale));
            font-weight: 100;
            white-space: pre-line;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .mark-read-btn {
            background: #071df5;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: calc(0.8rem * var(--font-scale));
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s ease;
        }

        .mark-read-btn:hover {
            background: #071df5;
        }

        .mark-read-btn.read {
            background: #28a745;
        }

        .mark-read-btn.read:hover {
            background: #218838;
        }

        .sync-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: calc(0.9rem * var(--font-scale));
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }

        .sync-notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .post-content {
            padding: 25px 30px 30px;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin: 15px 0 10px;
            color: #6a78f8;
            font-weight: 300;
        }

        .post-content h1 { font-size: calc(1.4rem * var(--font-scale)); color: #6a78f8; }
        .post-content h2 { font-size: calc(1.2rem * var(--font-scale)); color: #6a78f8; }
        .post-content h3, .post-content h4, .post-content h5, .post-content h6 {
            font-size: calc(1.0rem * var(--font-scale)); color: #6a78f8;
        }

        .post-content p {
            margin-bottom: 15px;
            color: #444;
        }

        .post-content ul,
        .post-content ol {
            margin: 15px 0;
            padding-left: 1px;
        }

        .post-content ul {
            list-style: none;
        }

        .post-content ul li {
            position: relative;
            margin-bottom: 8px;
            padding-left: 20px;
        }

        .post-content ul li::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0.6em;
            width: 6px;
            height: 6px;
            border-right: 1.5px solid #6a78f8;
            border-bottom: 1.5px solid #6a78f8;
            transform: rotate(-45deg);
        }

        .post-content ol li {
            margin-bottom: 8px;
        }

        .post-content ol {
            margin-left: 15px;
        }

        .post-content ol li::marker {
            color: #6a78f8;
        }

        .post-content blockquote {
            border-left: 4px solid #071df5;
            margin: 20px 0;
            padding: 15px 20px;
            background: #f8f9ff;
            border-radius: 0 8px 8px 0;
        }

        .post-content hr {
            border: none;
            border-top: 1px solid #555;
            margin: 10px 0;
            padding-bottom: 5px;
        }

        .post-content code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: calc(0.9em * var(--font-scale));
        }

        .post-content pre {
            background: #f8f8f8;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
        }

        .post-content pre code {
            background: none;
            padding: 0;
        }

        .post-content table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            border-radius: 8px;
            overflow: hidden;
            margin: 5px 0 20px 0;
        }

        .post-content th,
        .post-content td {
            border: 0.1px solid #2f2f2f;
            padding: 8px 12px;
            text-align: left;
            background: white;
            color: #999;
        }

        .post-content th:first-child,
        .post-content td:first-child {
            min-width: 75px;
        }

        .post-content th {
            font-weight: 100;
        }

        .post-content a {
            color: #071df5;
            text-decoration: none;
        }

        .post-content a:hover {
            text-decoration: underline;
        }

        /* Ensure all elements use font-weight 100 */
        body, html, strong, b, th, dt, .post-content strong, .post-content b,
        .post-content th, .post-content dt { font-weight: 100; }

        .no-posts {
            text-align: center;
            padding: 60px 20px;
            color: #666;
            font-size: calc(1.1rem * var(--font-scale));
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            header h1 {
                font-size: calc(2rem * var(--font-scale));
            }

            .post-header,
            .post-content {
                padding: 20px;
            }

            .post-title {
                font-size: calc(1.2rem * var(--font-scale));
                font-weight: 300;
            }
        }

        /* Bottom Tab Navigation */
        .bottom-tabs {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #2a2a2a;
            border-top: 1px solid #444;
            display: flex;
            z-index: 1000;
            padding: 0;
            margin: 0;
            transform: translateY(0);
            transition: transform 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .bottom-tabs.hidden {
            transform: translateY(100%);
            opacity: 0;
        }

        .tab-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 12px 8px;
            background: none;
            border: none;
            color: #999;
            text-decoration: none;
            transition: all 0.2s ease;
            cursor: pointer;
            min-height: 60px;
        }

        .tab-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
        }

        .tab-item.active {
            color: #6a78f8;
            background: #000;
            position: relative;
        }

        .tab-item.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: #6a78f8;
            border-radius: 0 0 2px 2px;
        }

        .tab-icon {
            width: 20px;
            height: 20px;
            margin-bottom: 4px;
            stroke: currentColor;
            fill: none;
        }

        .tab-label {
            font-size: 11px;
            font-weight: 500;
            text-align: center;
        }

        /* Add bottom padding to main content to account for tabs */
        .container {
            padding-bottom: 80px;
        }

        /* Dark mode styles for tabs */
        body.dark-mode .bottom-tabs {
            background: #1a1a1a;
            border-top-color: #333;
        }

        body.dark-mode .tab-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        body.dark-mode .tab-item.active {
            background: #000;
        }
    </style>
</head>
<body>
    <!-- Fixed Header -->
    <div class="header">
        <h1 class="header-title" id="header-title">Learner</h1>
        <!-- Header Audio Control - shown when audio is playing -->
        <div class="header-audio-control" id="header-audio-control">
            <button class="header-audio-btn" id="header-audio-btn" title="Mark as read">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" xmlns="http://www.w3.org/2000/svg">
                    <path d="M5 13l4 4L19 7" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
            </button>
        </div>
        <div class="header-progress" id="header-progress"></div>
        <button class="header-menu" id="header-menu" title="Settings">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="3" stroke="currentColor" stroke-width="2"/>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" stroke="currentColor" stroke-width="2"/>
            </svg>
        </button>
    </div>

    <div class="container">
        <div class="controls">
            <button class="sync-btn" id="sync-btn" onclick="syncAllForOffline()">
                Download Audios (0/0)
            </button>
            <button class="collapse-all-btn" id="collapse-all-btn" title="Collapse All">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 15L12 9L6 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
        </div>

        <!-- Hamburger Menu -->
        <div class="menu-overlay" id="menu-overlay"></div>
        <div class="menu-sidebar" id="menu-sidebar">
            <div class="menu-header">
                <div class="menu-title">Settings</div>
                <button class="menu-close" id="menu-close">&times;</button>
            </div>
            <div class="menu-item" id="theme-toggle-item">
                <div class="menu-item-label">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Dark Mode
                </div>
                <div class="theme-toggle" id="theme-toggle">
                    <div class="theme-toggle-slider"></div>
                </div>
            </div>
            <div class="menu-item" id="font-size-item">
                <div class="menu-item-label">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M4 7V4h16v3M9 20h6M12 4v16" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Font Size
                </div>
                <div class="font-size-controls">
                    <button class="font-size-btn" id="font-size-decrease">A-</button>
                    <span class="font-size-display" id="font-size-display">100%</span>
                    <button class="font-size-btn" id="font-size-increase">A+</button>
                </div>
            </div>
            <div class="menu-item" id="playback-speed-item">
                <div class="menu-item-label">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="5,3 19,12 5,21" stroke="currentColor" stroke-width="2" fill="none"/>
                        <path d="M19 12h2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                    Playback Speed
                </div>
                <div class="playback-speed-controls">
                    <button class="playback-speed-btn" id="playback-speed-decrease">-</button>
                    <span class="playback-speed-display" id="playback-speed-display">1.0x</span>
                    <button class="playback-speed-btn" id="playback-speed-increase">+</button>
                </div>
            </div>
            <div class="menu-item" id="auto-mark-read-item">
                <div class="menu-item-label">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 11l3 3L22 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Auto Mark Read
                </div>
                <div class="theme-toggle" id="auto-mark-read-toggle">
                    <div class="theme-toggle-slider"></div>
                </div>
            </div>
            <div class="menu-item" id="continuous-play-item">
                <div class="menu-item-label">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M17 3l4 4-4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M3 11V9a4 4 0 014-4h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M7 21l-4-4 4-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M21 13v2a4 4 0 01-4 4H3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Continuous Play
                </div>
                <div class="theme-toggle" id="continuous-play-toggle">
                    <div class="theme-toggle-slider"></div>
                </div>
            </div>
            <div class="menu-item" id="auto-preload-item">
                <div class="menu-item-label">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <polyline points="7 10 12 15 17 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <line x1="12" y1="15" x2="12" y2="3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Preload Audios
                </div>
                <div class="theme-toggle" id="auto-preload-toggle">
                    <div class="theme-toggle-slider"></div>
                </div>
            </div>

            <div class="menu-item" id="app-config-menu-item">
                <div class="menu-item-label">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" stroke="currentColor" stroke-width="2"/>
                    </svg>
                    App Configuration
                </div>
                <div class="api-key-status" id="app-config-status">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                        <path d="M9 12L11 14L15 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
            </div>

            <div class="menu-item" id="clear-audio-item">
                <div class="menu-item-label">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3 6h18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <line x1="10" y1="11" x2="10" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <line x1="14" y1="11" x2="14" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Clear All Audio Cache
                </div>
            </div>
        </div>

        <!-- Unified App Configuration Modal -->
        <div class="api-key-modal" id="unified-settings-modal">
            <div class="api-key-modal-content">
                <div class="api-key-modal-header">
                    <div class="api-key-modal-title">App Configuration</div>
                    <button class="api-key-modal-close" id="unified-settings-close">&times;</button>
                </div>

                <form class="api-key-form" id="unified-settings-form">
                    <!-- TTS API Key Section -->
                    <div class="settings-section-title">TTS API Key</div>
                    <div class="api-key-help">
                        Google Cloud Text-to-Speech API key for audio playback.
                    </div>
                    <div class="input-group">
                        <input type="text" class="api-key-input" id="unified-api-key-input" placeholder="Google Cloud TTS API key" autocomplete="off">
                        <button type="button" class="copy-btn" onclick="copyToClipboard('unified-api-key-input')" title="Copy API Key">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                    </div>

                    <!-- Webhook Section -->
                    <div class="settings-section-title">Webhook Config</div>
                    <div class="api-key-help">
                        Base URL for webhooks.
                    </div>
                    <div class="input-group">
                        <input type="url" class="api-key-input" id="unified-webhook-input" placeholder="api.domain.com/webhook" autocomplete="off">
                        <button type="button" class="copy-btn" onclick="copyToClipboard('unified-webhook-input')" title="Copy URL">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                    </div>

                    <!-- Data Source Section -->
                    <div class="settings-section-title">Data Source</div>
                    <div style="margin-bottom: 10px;">
                        <label class="input-label">Google Sheet ID</label>
                        <div class="input-group">
                            <input type="text" class="api-key-input" id="unified-sheet-id-input" placeholder="1a0SeElr...">
                            <button type="button" class="copy-btn" onclick="copyToClipboard('unified-sheet-id-input')" title="Copy Sheet ID">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <div style="flex: 1;">
                            <label class="input-label">Videos GID</label>
                            <input type="text" class="api-key-input" id="unified-videos-gid-input" placeholder="0">
                        </div>
                    </div>

                    <div class="api-key-buttons">
                        <button type="button" class="api-key-btn secondary" id="unified-settings-cancel">Cancel</button>
                        <button type="submit" class="api-key-btn" id="unified-settings-save">Save & Reload</button>
                    </div>

                    <!-- Bulk Configuration Section -->
                    <div class="bulk-config-container">
                        <div class="settings-section-title">Bulk Configuration</div>
                        <div class="api-key-help">
                            Manage all settings via clipboard JSON (Copy for backup, Apply to restore).
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button type="button" class="api-key-btn secondary" id="copy-bulk-config" style="padding: 6px 12px; font-size: 0.75rem;">Copy all as JSON</button>
                            <button type="button" class="api-key-btn" id="apply-bulk-config" style="padding: 6px 12px; font-size: 0.75rem; background-color: #28a745;">Apply from Clipboard</button>
                        </div>
                    </div>
                </form>
            </div>
        </div>

        <div class="main-content">
            <div id="loading" class="loading">
                Loading posts...
            </div>

            <div id="error" class="error" style="display: none;">
                Failed to load posts. Please try again later.
            </div>

            <!-- Videos Content (Default) -->
            <div id="videos-container" class="tab-content">
            </div>

            <div id="no-posts" class="no-posts" style="display: none;">
                No posts with summaries found.
            </div>
        </div>
    </div>

    <div class="floating-nav" id="floating-nav">
        <button id="floating-prev-post" aria-label="Previous article" title="Previous article">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="19 20 9 12 19 4 19 20"></polygon>
                <line x1="5" y1="19" x2="5" y2="5"></line>
            </svg>
        </button>
        <button id="floating-prev" aria-label="Skip backward 15 seconds" title="Skip backward 15 seconds">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                <path d="M3 3v5h5" />
                <text x="12" y="15.5" font-size="7" font-family="system-ui, -apple-system, sans-serif" text-anchor="middle" fill="currentColor" stroke="none" font-weight="600">15</text>
            </svg>
        </button>
        <button id="floating-mark" class="mark-action" aria-label="Play audio" title="Play audio">
            <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path d="M8 5v14l11-7z" stroke="none" />
            </svg>
        </button>
        <button id="floating-next" aria-label="Skip forward 15 seconds" title="Skip forward 15 seconds">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12a9 9 0 1 1-9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                <path d="M21 3v5h-5" />
                <text x="12" y="15.5" font-size="7" font-family="system-ui, -apple-system, sans-serif" text-anchor="middle" fill="currentColor" stroke="none" font-weight="600">15</text>
            </svg>
        </button>
        <button id="floating-next-post" aria-label="Next article" title="Next article">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="5 4 15 12 5 20 5 4"></polygon>
                <line x1="19" y1="5" x2="19" y2="19"></line>
            </svg>
        </button>
    </div>


    <script>
        // Load configuration from localStorage
        const SHEET_ID = localStorage.getItem('learner_sheet_id') || '';
        const VIDEOS_GID = localStorage.getItem('learner_videos_gid') || '';

        const SHEET_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&tq=&gid=${VIDEOS_GID}`;

        // Data caching system
        let cachedData = {
            videos: null
        };

        // IndexedDB Cache System
        const DB_NAME = 'LearnerCache';
        const DB_VERSION = 1;
        const STORES = {
            DATA: 'data_cache',
            AUDIO: 'audio_cache'
        };

        const AppCache = {
            db: null,
            init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(STORES.DATA)) db.createObjectStore(STORES.DATA);
                        if (!db.objectStoreNames.contains(STORES.AUDIO)) db.createObjectStore(STORES.AUDIO);
                    };
                    request.onsuccess = (e) => {
                        this.db = e.target.result;
                        resolve();
                    };
                    request.onerror = (e) => reject(e);
                });
            },
            async get(store, key) {
                if (!this.db) await this.init();
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction(store, 'readonly');
                    const request = tx.objectStore(store).get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },
            async set(store, key, value) {
                if (!this.db) await this.init();
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction(store, 'readwrite');
                    const request = tx.objectStore(store).put(value, key);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            },
            async delete(store, key) {
                if (!this.db) await this.init();
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction(store, 'readwrite');
                    const request = tx.objectStore(store).delete(key);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            },
            async getAllKeys(store) {
                if (!this.db) await this.init();
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction(store, 'readonly');
                    const request = tx.objectStore(store).getAllKeys();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },
            async clear(store) {
                if (!this.db) await this.init();
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction(store, 'readwrite');
                    const request = tx.objectStore(store).clear();
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }
        };

        async function removeAudioFromCache(postDiv) {
            const listenBtn = postDiv.querySelector('.listen-btn');
            if (!listenBtn) return;
            try {
                const text = getSpeechText(listenBtn);
                const useChinese = containsChinese(text);
                const voice = useChinese ? GOOGLE_CLOUD_TTS_CONFIG.voice : GOOGLE_CLOUD_TTS_CONFIG.fallbackVoice;
                const cacheKey = await hashText(text + voice.languageCode + voice.ssmlGender);
                await AppCache.delete(STORES.AUDIO, cacheKey);
                console.log('%c Audio removed from IndexedDB (post read/archived)', 'color: #f44336');
            } catch (e) {
                console.error('Failed to remove audio from cache:', e);
            }
        }

        async function hashText(text) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Helper function to merge multiple base64 audio chunks into one
        function mergeBase64Audio(base64Array) {
            try {
                // Convert all base64 to Uint8Arrays
                const pieces = base64Array.map(b64 => {
                    const binary = atob(b64);
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) {
                        bytes[i] = binary.charCodeAt(i);
                    }
                    return bytes;
                });

                // Calculate total size and concatenate
                const totalSize = pieces.reduce((acc, p) => acc + p.length, 0);
                const merged = new Uint8Array(totalSize);
                let offset = 0;
                for (const piece of pieces) {
                    merged.set(piece, offset);
                    offset += piece.length;
                }

                // Convert back to base64 in chunks (to avoid stack overflow)
                let binaryOutput = '';
                const CHUNK_SIZE = 16384;
                for (let i = 0; i < merged.length; i += CHUNK_SIZE) {
                    binaryOutput += String.fromCharCode.apply(null, merged.subarray(i, i + CHUNK_SIZE));
                }
                return btoa(binaryOutput);
            } catch (error) {
                console.error('Failed to merge audio chunks:', error);
                return null;
            }
        }

        let currentTab = 'videos'; // Default tab

        // Global shared audio player to handle continuous play and bypass autoplay restrictions
        window.sharedAudio = new Audio();
        window.sharedAudio._unlocked = false;

        // Track the current active button for audio control (including lock screen)
        window.currentAudioButton = null;

        function getSharedAudio() {
            const audio = window.sharedAudio;
            // Clear all possible dynamic listeners before reuse
            audio.onended = null;
            audio.ontimeupdate = null;
            audio.onerror = null;
            audio.onplaying = null;
            audio.onpause = null;
            audio.onloadstart = null;
            return audio;
        }

        // Function to update the Media Session API for lock screen and hardware controls
        function updateMediaSession(button) {
            if (!('mediaSession' in navigator)) return;

            if (!button) {
                navigator.mediaSession.playbackState = 'none';
                return;
            }

            const post = button.postData;
            const isPlaying = button.speechState.isPlaying && !button.speechState.isPaused;

            // Set metadata
            navigator.mediaSession.metadata = new MediaMetadata({
                title: post.title || 'Untitled',
                artist: 'Learner',
                album: 'Learner Audio',
                artwork: [
                    { src: 'https://i.imgur.com/nXRkDYO.png', sizes: '96x96', type: 'image/png' },
                    { src: 'https://i.imgur.com/nXRkDYO.png', sizes: '128x128', type: 'image/png' },
                    { src: 'https://i.imgur.com/nXRkDYO.png', sizes: '192x192', type: 'image/png' },
                    { src: 'https://i.imgur.com/nXRkDYO.png', sizes: '256x256', type: 'image/png' },
                    { src: 'https://i.imgur.com/nXRkDYO.png', sizes: '384x384', type: 'image/png' },
                    { src: 'https://i.imgur.com/nXRkDYO.png', sizes: '512x512', type: 'image/png' },
                ]
            });

            // Set playback state
            navigator.mediaSession.playbackState = isPlaying ? 'playing' : 'paused';

            // Register action handlers
            navigator.mediaSession.setActionHandler('play', () => {
                console.log('Media Session: play (AirPod/Lockscreen)');
                if (button.speechState.isPaused || !button.speechState.isPlaying) {
                    toggleSpeech(button);
                }
            });

            navigator.mediaSession.setActionHandler('pause', () => {
                console.log('Media Session: pause (AirPod/Lockscreen)');
                if (button.speechState.isPlaying && !button.speechState.isPaused) {
                    toggleSpeech(button);
                }
            });

            navigator.mediaSession.setActionHandler('previoustrack', () => {
                const prevPostBtn = document.getElementById('floating-prev-post');
                if (prevPostBtn) prevPostBtn.click();
            });

            navigator.mediaSession.setActionHandler('nexttrack', () => {
                const nextPostBtn = document.getElementById('floating-next-post');
                if (nextPostBtn) nextPostBtn.click();
            });

            navigator.mediaSession.setActionHandler('seekbackward', (details) => {
                const skipTime = details.seekOffset || 15;
                window.sharedAudio.currentTime = Math.max(0, window.sharedAudio.currentTime - skipTime);
            });

            navigator.mediaSession.setActionHandler('seekforward', (details) => {
                const skipTime = details.seekOffset || 15;
                window.sharedAudio.currentTime = Math.min(window.sharedAudio.duration || Infinity, window.sharedAudio.currentTime + skipTime);
            });

            navigator.mediaSession.setActionHandler('stop', () => {
                stopAllPlayback();
            });
        }

        // Listen for hardware/system pause events to keep UI in sync
        window.sharedAudio.addEventListener('pause', () => {
            if (window.currentAudioButton) {
                const button = window.currentAudioButton;
                const state = button.speechState;
                if (state.isPlaying && !state.isPaused) {
                    console.log('Audio element paused externally (system/hardware)');
                    state.isPlaying = false;
                    state.isPaused = true;
                    button.classList.remove('playing');
                    button.classList.add('paused');
                    button.innerHTML = `
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <polygon points="5,3 19,12 5,21" stroke="currentColor" stroke-width="2" fill="none"/>
                        </svg>
                    `;
                    updateFloatingMarkState();
                    updateMediaSession(button);
                }
            }
        });

        window.sharedAudio.addEventListener('play', () => {
            if (window.currentAudioButton) {
                const button = window.currentAudioButton;
                const state = button.speechState;
                if (!state.isPlaying && state.isPaused) {
                    console.log('Audio element played externally (system/hardware)');
                    state.isPlaying = true;
                    state.isPaused = false;
                    button.classList.remove('paused');
                    button.classList.add('playing');
                    button.innerHTML = `
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <rect x="6" y="4" width="4" height="16" fill="currentColor"/>
                            <rect x="14" y="4" width="4" height="16" fill="currentColor"/>
                        </svg>
                    `;
                    updateFloatingMarkState();
                    updateMediaSession(button);
                }
            }
        });

        // Update header progress bar based on audio playback progress
        window.sharedAudio.addEventListener('timeupdate', () => {
            const headerProgress = document.getElementById('header-progress');
            if (headerProgress) {
                if (window.sharedAudio.duration && isFinite(window.sharedAudio.duration)) {
                    const progress = (window.sharedAudio.currentTime / window.sharedAudio.duration) * 100;
                    headerProgress.style.width = `${progress}%`;
                } else {
                    headerProgress.style.width = '0%';
                }
            }
        });

        // Reset progress when audio ends or starts loading new source
        window.sharedAudio.addEventListener('ended', () => {
            const headerProgress = document.getElementById('header-progress');
            if (headerProgress) headerProgress.style.width = '0%';
        });

        window.sharedAudio.addEventListener('loadstart', () => {
            const headerProgress = document.getElementById('header-progress');
            if (headerProgress) headerProgress.style.width = '0%';
        });

        // Function to unlock audio on first human interaction
        function unlockAudio() {
            if (window.sharedAudio._unlocked) return;

            console.log('Unlocking audio context...');
            // Use a tiny 0.1s silent MP3 as a "blessing" source
            const silentMP3 = 'data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGFtZTMuMTAwAaaaaaaaaaaaaAAA//MUxAAAAAYAHAAAAAL7mUAAAAAAf0AAABXAFBFAAAAAAAA//MUxAsAAAYAHAAAAAL7mUAAAAAAf0AAABXAFBFAAAAAAAA//MUxBAAAAYAHAAAAAL7mUAAAAAAf0AAABXAFBFAAAAAAAA';

            const audio = window.sharedAudio;
            const originalSrc = audio.src;

            audio.src = silentMP3;
            audio.play().then(() => {
                audio.pause();
                audio.src = originalSrc || '';
                window.sharedAudio._unlocked = true;
                console.log('Audio context unlocked');
            }).catch(e => {
                console.warn('Audio unlock failed or deferred:', e.message);
                // On iOS, we might still be able to play later if we touched it
                window.sharedAudio._unlocked = true;
            });
        }

        // Handle page refresh/clean start logic
        window.addEventListener('load', () => {
            console.log('Initial page load: clearing all audio states');
            if (window.sharedAudio) {
                window.sharedAudio.pause();
                window.sharedAudio.src = '';
                window.sharedAudio._unlocked = false;
            }
            const headerProgress = document.getElementById('header-progress');
            if (headerProgress) headerProgress.style.width = '0%';
            window.currentAudioButton = null;
        });

        // Global callback function for JSONP
        window.googleSheetsCallback = function(data) {
            window.sheetsData = data;
        };

        function formatDate(dateString, includeTime = false) {
            if (!dateString) return 'No date';

            try {
                let year, month, day, hours = 0, minutes = 0;
                let hasTime = false;

                // Handle Google Sheets date format: "Date(2025,10,30,17,31,0)" or "Date(2025,10,17)"
                if (typeof dateString === 'string' && dateString.startsWith('Date(')) {
                    const match = dateString.match(/Date\((\d+),(\d+),(\d+)(?:,(\d+),(\d+),(\d+))?\)/);
                    if (match) {
                        year = parseInt(match[1]);
                        month = parseInt(match[2]) + 1; // Google Sheets months are 0-indexed, so add 1
                        day = parseInt(match[3]);

                        if (match[4] !== undefined) {
                            hours = parseInt(match[4]);
                            minutes = parseInt(match[5]);
                            hasTime = true;
                        }
                    }
                }

                if (year === undefined) {
                    const date = new Date(dateString);
                    if (isNaN(date.getTime())) return dateString;
                    year = date.getFullYear();
                    month = date.getMonth() + 1;
                    day = date.getDate();
                    hours = date.getHours();
                    minutes = date.getMinutes();
                    hasTime = true;
                }

                const formattedMonth = month.toString().padStart(2, '0');
                const formattedDay = day.toString().padStart(2, '0');
                const datePart = `${year}/${formattedMonth}/${formattedDay}`;

                if (includeTime && hasTime) {
                    const formattedHours = hours.toString().padStart(2, '0');
                    const formattedMinutes = minutes.toString().padStart(2, '0');
                    return `${datePart} ${formattedHours}:${formattedMinutes}`;
                }

                return datePart;
            } catch (e) {
                return dateString;
            }
        }

        function createPostElement(post) {
            const postDiv = document.createElement('div');
            postDiv.className = 'blog-post';

            const headerDiv = document.createElement('div');
            headerDiv.className = 'post-header';

            const titleElement = document.createElement('h1');
            titleElement.className = 'post-title';

            if (post.videoUrl && post.videoUrl.trim()) {
                const titleLink = document.createElement('a');
                titleLink.href = post.videoUrl;
                titleLink.target = '_blank';
                titleLink.rel = 'noopener noreferrer';
                titleLink.textContent = post.title || 'Untitled';
                titleElement.appendChild(titleLink);
            } else {
                titleElement.textContent = post.title || 'Untitled';
            }

            const titleContainer = document.createElement('div');
            titleContainer.className = 'post-title-container';
            titleContainer.appendChild(titleElement);

            let listenBtn = null;

            // Create metadata and listen button for both videos and notes
            const dateElement = document.createElement('div');
            dateElement.className = 'post-date';

            const metadataInfo = document.createElement('div');
            metadataInfo.style.flex = '1';
            metadataInfo.style.whiteSpace = 'pre-line';

            let dateText = "";
            if (post.publishedAt) {
                dateText = `Published: ${formatDate(post.publishedAt)}`;
            }

            const readingTime = calculateReadingTime(post.summary || '');
            const readingTimeSpan = document.createElement('span');
            readingTimeSpan.className = 'reading-time';
            readingTimeSpan.textContent = readingTime;

            const audioStatusSpan = document.createElement('span');
            audioStatusSpan.className = 'audio-status';

            if (dateText) {
                metadataInfo.textContent = dateText;
                metadataInfo.appendChild(document.createElement('br'));
            }
            metadataInfo.appendChild(readingTimeSpan);
            metadataInfo.appendChild(audioStatusSpan);

            dateElement.appendChild(metadataInfo);

            listenBtn = document.createElement('button');
            listenBtn.className = 'listen-btn';
            listenBtn.innerHTML = `
                <svg width="14" height="14" viewBox="0 0 20 22" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <polygon points="5,3 19,12 5,21" stroke="currentColor" stroke-width="2" fill="none"/>
                </svg>
            `;

            listenBtn.postData = post;
            listenBtn.speechState = {
                audio: null,
                isPlaying: false,
                isPaused: false,
                preloadedResult: null,
                isLoading: false,
                totalPlayTime: 0,
                lastPlayStartTime: null
            };

            listenBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                unlockAudio(); // CRITICAL: unlock audio on first click
                toggleSpeech(listenBtn);
            });

            dateElement.appendChild(listenBtn);
            // Reordered: Don't append dateElement here anymore, it's done after titleContainer below

            // Initialize post state
            if (post.isRead) {
                postDiv.classList.add('read');
            }
            // All posts start collapsed by default
            postDiv.classList.add('collapsed');

            // Create bottom mark read button
            const markReadBtnBottom = document.createElement('button');
            markReadBtnBottom.className = 'mark-read-btn-bottom';

            // Initialize bottom button state
            if (post.isRead) {
                markReadBtnBottom.textContent = 'Mark as unread';
                markReadBtnBottom.classList.add('read');
            } else {
                markReadBtnBottom.textContent = 'Mark as read';
            }

            markReadBtnBottom.addEventListener('click', function() {
                toggleReadStatus(postDiv, markReadBtnBottom, post.videoUrl);
            });

            // Add click handler to header for collapse/expand
            headerDiv.addEventListener('click', function(e) {
                // Don't trigger if clicking on buttons
                if (e.target === markReadBtnBottom) {
                    return;
                }
                if (listenBtn && (e.target === listenBtn || e.target.closest('.listen-btn'))) {
                    return;
                }
                toggleCollapse(postDiv);
            });

            headerDiv.appendChild(titleContainer);
            headerDiv.appendChild(dateElement);

            // Add YouTube embed to header if video URL exists
            if (post.videoUrl && post.videoUrl.trim()) {
                const youtubeEmbed = createYouTubeEmbed(post.videoUrl);
                if (youtubeEmbed) {
                    headerDiv.appendChild(youtubeEmbed);
                }
            }

            const contentDiv = document.createElement('div');
            contentDiv.className = 'post-content';

            try {
                // Parse markdown to HTML
                let htmlContent = marked.parse(post.summary || '');

                // Remove the first H1 title from content (it's already in the header)
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                const firstH1 = tempDiv.querySelector('h1');
                if (firstH1) {
                    firstH1.remove();
                }
                contentDiv.innerHTML = tempDiv.innerHTML;
            } catch (e) {
                console.error('Error parsing markdown:', e);
                // Fallback to plain text with line breaks
                contentDiv.innerHTML = (post.summary || '').replace(/\n/g, '<br>');
            }

            // Add bottom button to content
            contentDiv.appendChild(markReadBtnBottom);

            postDiv.appendChild(headerDiv);
            postDiv.appendChild(contentDiv);

            // Check if audio is ready to set initial border
            updatePostReadyStatus(postDiv);

            return postDiv;
        }

        function loadDataWithJSONP(url) {
            return new Promise((resolve, reject) => {
                // Create a unique callback name for this specific request
                const callbackId = 'cb' + Math.floor(Math.random() * 1000000);
                const callbackName = `handleGoogleSheetsResponse_${callbackId}`;

                // Define the cleanup function
                const cleanup = () => {
                    delete window[callbackName];
                    const script = document.getElementById(callbackId);
                    if (script) script.remove();
                };

                const script = document.createElement('script');
                script.id = callbackId;

                // Set a timeout of 15 seconds
                const timeoutId = setTimeout(() => {
                    cleanup();
                    reject(new Error('JSONP request timed out'));
                }, 15000);

                // Handle script loading errors
                script.onerror = () => {
                    clearTimeout(timeoutId);
                    cleanup();
                    reject(new Error('Failed to load JSONP script'));
                };

                window[callbackName] = function(response) {
                    clearTimeout(timeoutId);
                    cleanup();
                    resolve(response);
                };

                // Construct the URL with the custom response handler
                let finalUrl = url;
                if (finalUrl.includes('tqx=out:json')) {
                    finalUrl = finalUrl.replace('tqx=out:json', `tqx=out:json;responseHandler:${callbackName}`);
                } else if (finalUrl.includes('?')) {
                    finalUrl += `&tqx=responseHandler:${callbackName}`;
                } else {
                    finalUrl += `?tqx=responseHandler:${callbackName}`;
                }

                script.src = finalUrl;
                document.body.appendChild(script);
            });
        }

        async function loadTabData(tabType, forceNetwork = false) {
            if (!SHEET_ID) {
                console.warn('Data Source not configured');
                return { table: { rows: [] } };
            }

            // Return memory cache if not forcing network
            if (!forceNetwork && cachedData[tabType]) {
                return cachedData[tabType];
            }

            try {
                const url = SHEET_URL;
                const data = await loadDataWithJSONP(url);

                // Update persistent and memory cache
                await AppCache.set(STORES.DATA, tabType, data);
                cachedData[tabType] = data;
                console.log(`%c Fresh ${tabType} data loaded from network`, 'color: #4CAF50');
                return data;
            } catch (error) {
                console.warn(`Network failed for ${tabType}, trying IndexedDB:`, error);
                const cached = await AppCache.get(STORES.DATA, tabType);
                if (cached) {
                    cachedData[tabType] = cached;
                    return cached;
                }
                throw error;
            }
        }

        async function renderTabContent(tabType) {
            const container = document.getElementById(`${tabType}-container`);
            const loadingElement = document.getElementById('loading');
            const errorElement = document.getElementById('error');
            const noPostsElement = document.getElementById('no-posts');

            const updateUI = async (data) => {
                if (!data || !data.table || !data.table.rows) {
                    console.warn(`Empty or invalid data received for ${tabType}`);
                    // If we already have items displayed, don't wipe them out with a bad update
                    if (container.children.length === 0) {
                        loadingElement.style.display = 'none';
                        noPostsElement.style.display = 'block';
                    }
                    return;
                }

                const rows = data.table.rows;
                const cols = data.table.cols;

                // Log column labels to help debug if they are missing
                const columnLabels = cols.map(c => c.label ? c.label.toLowerCase() : '');
                console.log(`Column labels for ${tabType}:`, columnLabels);

                const columnMap = {};
                cols.forEach((col, index) => { if (col.label) columnMap[col.label.toLowerCase()] = index; });

                const posts = rows.map(row => {
                    if (!row.c) return null;
                    let title, videoUrl, addedAt, publishedAt, summary, isRead;

                    title = columnMap['video title'] >= 0 && row.c[columnMap['video title']] ? row.c[columnMap['video title']].v : '';
                    videoUrl = columnMap['video url'] >= 0 && row.c[columnMap['video url']] ? row.c[columnMap['video url']].v : '';
                    addedAt = columnMap['added at'] >= 0 && row.c[columnMap['added at']] ? row.c[columnMap['added at']].v : '';
                    publishedAt = columnMap['published at'] >= 0 && row.c[columnMap['published at']] ? row.c[columnMap['published at']].v : '';
                    summary = columnMap['summary'] >= 0 && row.c[columnMap['summary']] ? row.c[columnMap['summary']].v : '';
                    isRead = columnMap['read'] >= 0 && row.c[columnMap['read']] ? (row.c[columnMap['read']].v === 1 || row.c[columnMap['read']].v === '1') : false;

                    if (!summary || !summary.trim()) return null;
                    return { title, videoUrl, addedAt, publishedAt, summary: summary.trim(), isRead, tabType: 'videos' };
                }).filter(p => p !== null).sort((a, b) => new Date(b.addedAt) - new Date(a.addedAt));

                // Diffing logic
                const existingBlocks = Array.from(container.children);
                const postIds = posts.map(p => p.videoUrl);

                // Remove deleted ones
                existingBlocks.forEach(block => {
                    const blockId = block.getAttribute('data-id');
                    if (!postIds.includes(blockId)) block.remove();
                });

                // Update or Add
                posts.forEach((post, index) => {
                    const postId = post.videoUrl;
                    let existing = container.querySelector(`[data-id="${postId}"]`);

                    if (existing) {
                        // Check if status changed (Read)
                        const wasRead = existing.classList.contains('read');
                        const isNowRead = post.isRead;
                        if (wasRead !== isNowRead) {
                            const newBlock = createPostElement(post);
                            newBlock.setAttribute('data-id', postId);
                            container.replaceChild(newBlock, existing);
                        }
                    } else {
                        const newBlock = createPostElement(post);
                        newBlock.setAttribute('data-id', postId);
                        if (index === 0) container.prepend(newBlock);
                        else {
                            const prevId = posts[index-1].videoUrl;
                            const prevBlock = container.querySelector(`[data-id="${prevId}"]`);
                            if (prevBlock) prevBlock.after(newBlock);
                            else container.appendChild(newBlock);
                        }
                    }
                });

                loadingElement.style.display = 'none';
                noPostsElement.style.display = posts.length === 0 ? 'block' : 'none';

                // Final Console Summary (always called after update)
                updateSyncStatusDisplay();
            };

            // Phase 1: Try immediate render from IndexedDB cache
            const cached = await AppCache.get(STORES.DATA, tabType);
            if (cached) {
                console.log(`%c Rendering ${tabType} from cache (Instant)`, 'color: #2196F3');
                updateUI(cached);
            } else {
                loadingElement.style.display = 'block';
            }

            // Phase 2: Refresh from network in background
            try {
                const fresh = await loadTabData(tabType, true);
                updateUI(fresh);
            } catch (e) {
                console.warn(`Background refresh failed for ${tabType}:`, e);
                loadingElement.style.display = 'none';
            }
        }

        // Initialize with default tab (videos)
        async function loadPosts() {
            await renderTabContent('videos');

            // Initial sync check
            updateSyncStatusDisplay();

            // Load autoPreload setting if not already loaded
            if (window.autoPreloadEnabled === undefined) {
                window.autoPreloadEnabled = localStorage.getItem('learner_auto_preload') === 'true';
            }

            // Auto preload if enabled
            if (isOnline) {
                if (window.autoPreloadEnabled) {
                    console.log('Preloading all audios as per setting...');
                    setTimeout(() => syncAllForOffline(), 1000);
                } else {
                    console.log('Preloading only the first audio (auto-preload disabled)...');
                    setTimeout(() => syncAllForOffline(1), 1000);
                }
            }
        }

        async function updatePostReadyStatus(postDiv) {
            const listenBtn = postDiv.querySelector('.listen-btn');
            const audioStatusSpan = postDiv.querySelector('.audio-status');
            if (!listenBtn) return;

            try {
                const text = getSpeechText(listenBtn);
                const useChinese = containsChinese(text);
                const voice = useChinese ? GOOGLE_CLOUD_TTS_CONFIG.voice : GOOGLE_CLOUD_TTS_CONFIG.fallbackVoice;
                const cacheKey = await hashText(text + voice.languageCode + voice.ssmlGender);
                const cached = await AppCache.get(STORES.AUDIO, cacheKey);

                if (cached) {
                    if (cached.status === 'done') {
                        postDiv.classList.remove('audio-not-ready');
                        if (audioStatusSpan) {
                            audioStatusSpan.className = 'audio-status downloaded';
                            audioStatusSpan.innerHTML = `
                                <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                                <span>Audio</span>
                            `;
                        }
                    } else if (cached.status === 'in_progress') {
                        postDiv.classList.add('audio-not-ready');
                        if (audioStatusSpan) {
                            audioStatusSpan.className = 'audio-status syncing';
                            audioStatusSpan.innerHTML = `
                                <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" style="animation: spin 1s linear infinite;">
                                    <path d="M21 12a9 9 0 11-6.219-8.56"></path>
                                </svg>
                                <span>Audio</span>
                            `;
                        }
                    } else {
                         postDiv.classList.add('audio-not-ready');
                         if (audioStatusSpan) {
                            audioStatusSpan.className = 'audio-status todo';
                            audioStatusSpan.innerHTML = '<span>Audio</span>';
                        }
                    }
                } else {
                    postDiv.classList.add('audio-not-ready');
                    if (audioStatusSpan) {
                        audioStatusSpan.className = 'audio-status todo';
                        audioStatusSpan.innerHTML = '<span>Audio</span>';
                    }
                }
            } catch (e) {
                console.error('Error checking audio readiness:', e);
            }
        }

        async function updateAllPostsReadyStatus() {
            const posts = Array.from(document.querySelectorAll('.blog-post'));
            // Process in parallel to avoid sequential delay
            await Promise.all(posts.map(post => updatePostReadyStatus(post)));
        }

        async function updateSyncStatusDisplay() {
            try {
                // Update all borders based on cache
                await updateAllPostsReadyStatus();

                const videos = await getAllPostsSync();

                const allUnread = videos.filter(p => {
                    // Check DOM first for most up-to-date local status
                    const postElement = document.querySelector(`[data-id="${p.videoUrl}"]`);
                    if (postElement) {
                        return !postElement.classList.contains('read');
                    }
                    return !p.isRead;
                });

                let syncedCount = 0;
                let inProgressCount = 0;
                let pendingCount = 0;

                for (const post of allUnread) {
                    const text = getPostSpeechText(post);
                    const useChinese = containsChinese(text);
                    const voice = useChinese ? GOOGLE_CLOUD_TTS_CONFIG.voice : GOOGLE_CLOUD_TTS_CONFIG.fallbackVoice;
                    const cacheKey = await hashText(text + voice.languageCode + voice.ssmlGender);
                    const cached = await AppCache.get(STORES.AUDIO, cacheKey);

                    if (cached) {
                        if (cached.status === 'done') syncedCount++;
                        else if (cached.status === 'in_progress') inProgressCount++;
                        else pendingCount++;
                    } else {
                        pendingCount++;
                    }
                }

                // Update Download Button Text
                const syncBtn = document.getElementById('sync-btn');
                if (syncBtn && !syncBtn.classList.contains('syncing')) {
                    syncBtn.textContent = `Download Audios (${syncedCount}/${allUnread.length})`;
                }

                // Log summary to console with grouping for prominence
                console.group('%c Audio Sync Summary', 'color: #6a78f8; font-weight: bold; font-size: 1.2em');
                console.log(`%cTotal Unread Posts: %c${allUnread.length}`, 'font-weight: bold', 'color: #000');
                console.log(`%c Fully Synced:     %c${syncedCount}`, 'font-weight: bold', 'color: #4CAF50');
                console.log(`%c In Progress:      %c${inProgressCount}`, 'font-weight: bold', 'color: #FF9800');
                console.log(`%c Not Downloaded:  %c${pendingCount}`, 'font-weight: bold', 'color: #f44336');
                console.groupEnd();
            } catch (e) {
                console.error('Failed to update sync status display:', e);
            }
        }

        function toggleCollapse(postDiv) {
            postDiv.classList.toggle('collapsed');
            // Trigger floating nav visibility update
            window.dispatchEvent(new Event('resize'));
        }

        function scrollToNextPost(currentPostDiv) {
            const allPosts = document.querySelectorAll('.blog-post');
            const currentIndex = Array.from(allPosts).indexOf(currentPostDiv);

            if (currentIndex >= 0 && currentIndex < allPosts.length - 1) {
                const nextPost = allPosts[currentIndex + 1];
                const offset = nextPost.offsetTop - 20; // 20px extra padding

                window.scrollTo({
                    top: offset,
                    behavior: 'smooth'
                });
            }
        }

        // Auto mark post as read when audio finishes (if enabled)
        function autoMarkPostAsRead(listenButton) {
            // Check if setting is enabled
            if (!window.autoMarkReadEnabled) return;

            if (!listenButton) return;

            // Find the post containing this listen button
            const postDiv = listenButton.closest('.blog-post');
            if (!postDiv) return;

            // Skip if already read
            if (postDiv.classList.contains('read')) return;

            // Find the bottom mark-as-read button and click it
            const bottomBtn = postDiv.querySelector('.mark-read-btn-bottom');
            if (bottomBtn) {
                console.log('Auto-marking post as read after audio finished');
                bottomBtn.click();
            }
        }

        // Auto play next post's audio when current finishes (if enabled)
        function autoContinuousPlay(listenButton) {
            // Check if setting is enabled
            if (!window.continuousPlayEnabled) return;

            if (!listenButton) return;

            // Find the post containing this listen button
            const postDiv = listenButton.closest('.blog-post');
            if (!postDiv) return;

            // Find the next post
            const container = postDiv.parentElement;
            const allPosts = Array.from(container.querySelectorAll('.blog-post'));
            const currentIndex = allPosts.indexOf(postDiv);

            if (currentIndex >= 0 && currentIndex < allPosts.length - 1) {
                const nextPost = allPosts[currentIndex + 1];

                // Find the listen button in the next post
                const nextListenBtn = nextPost.querySelector('.listen-btn');
                if (nextListenBtn) {
                    console.log('Continuous play: starting audio for next post');
                    // Small delay to let the current audio fully clean up.
                    // Reduced to 100ms to keep gesture/engagement link stronger.
                    setTimeout(() => {
                        toggleSpeech(nextListenBtn);
                    }, 100);
                }
            }
        }

        function toggleReadStatus(postDiv, button, videoUrl) {
            const isRead = postDiv.classList.contains('read');

            // Find the bottom button
            const bottomButton = postDiv.querySelector('.mark-read-btn-bottom');

            if (isRead) {
                // Mark as unread - force expand
                postDiv.classList.remove('read', 'collapsed');

                // Update button
                if (bottomButton) {
                    bottomButton.textContent = 'Mark as read';
                    bottomButton.classList.remove('read');
                }

                // Call webhook for unread (read=0)
                callWebhook(videoUrl, 0);
                updateSyncStatusDisplay();
            } else {
                // Mark as read - force collapse
                postDiv.classList.add('read', 'collapsed');

                // Update button
                if (bottomButton) {
                    bottomButton.textContent = 'Mark as unread';
                    bottomButton.classList.add('read');
                }

                // Call webhook for read (read=1)
                callWebhook(videoUrl, 1);

                // Preload next post audio
                preloadNextPostAudio(postDiv);

                // Remove audio from cache when marking as read
                removeAudioFromCache(postDiv);
                updateSyncStatusDisplay();

                // Scroll to next post after marking as read
                setTimeout(() => {
                    scrollToNextPost(postDiv);
                }, 300); // Small delay to allow collapse animation
            }
        }

        function toggleReadStatusNoCollapse(postDiv, button, videoUrl) {
            const isRead = postDiv.classList.contains('read');

            // Find both buttons to sync them
            const topButton = postDiv.querySelector('.mark-read-btn');
            const bottomButton = postDiv.querySelector('.mark-read-btn-bottom');

            if (isRead) {
                // Mark as unread - don't change collapse state
                postDiv.classList.remove('read');

                // Update both buttons
                if (topButton) {
                    topButton.textContent = 'Mark as read';
                    topButton.classList.remove('read');
                }
                if (bottomButton) {
                    bottomButton.textContent = 'Mark as read';
                    bottomButton.classList.remove('read');
                }

                // Call webhook for unread (read=0)
                callWebhook(videoUrl, 0);
                updateSyncStatusDisplay();
            } else {
                // Mark as read - don't change collapse state
                postDiv.classList.add('read');

                // Update both buttons
                if (topButton) {
                    topButton.textContent = 'Mark as unread';
                    topButton.classList.add('read');
                }
                if (bottomButton) {
                    bottomButton.textContent = 'Mark as unread';
                    bottomButton.classList.add('read');
                }

                // Call webhook for read (read=1)
                callWebhook(videoUrl, 1);

                // Preload next post audio
                preloadNextPostAudio(postDiv);

                // Remove audio from cache when marking as read
                removeAudioFromCache(postDiv);
                updateSyncStatusDisplay();

                // Scroll to next post after marking as read
                setTimeout(() => {
                    scrollToNextPost(postDiv);
                }, 300); // Small delay to allow collapse animation
            }
        }



        // Offline queue management
        let offlineQueue = JSON.parse(localStorage.getItem('learner_offline_queue') || '[]');
        let isOnline = navigator.onLine;

        // Save queue to localStorage
        function saveQueue() {
            localStorage.setItem('learner_offline_queue', JSON.stringify(offlineQueue));
        }

        // Add action to offline queue
        function queueAction(videoUrl, readStatus) {
            const action = {
                id: Date.now() + Math.random(),
                videoUrl: videoUrl,
                readStatus: readStatus,
                timestamp: new Date().toISOString()
            };

            // Remove any existing action for the same video to avoid duplicates
            offlineQueue = offlineQueue.filter(item => item.videoUrl !== videoUrl);
            offlineQueue.push(action);
            saveQueue();

            console.log('Action queued for offline sync:', action);
            showOfflineNotification('Action saved for when you\'re back online');
        }

        // Process offline queue when back online
        function processOfflineQueue() {
            if (offlineQueue.length === 0) return;

            console.log(`Processing ${offlineQueue.length} queued actions...`);
            showSyncNotification('Syncing offline actions...');

            const queueCopy = [...offlineQueue];
            offlineQueue = [];
            saveQueue();

            let processed = 0;
            let failed = [];

            queueCopy.forEach(action => {
                callWebhookDirect(action.videoUrl, action.readStatus)
                    .then(() => {
                        processed++;
                        if (processed + failed.length === queueCopy.length) {
                            if (failed.length === 0) {
                                showSyncNotification('All offline actions synced successfully!');
                            } else {
                                // Re-queue failed actions
                                offlineQueue = [...offlineQueue, ...failed];
                                saveQueue();
                                showSyncNotification(`${processed} actions synced, ${failed.length} failed`);
                            }
                        }
                    })
                    .catch(() => {
                        failed.push(action);
                        if (processed + failed.length === queueCopy.length) {
                            // Re-queue failed actions
                            offlineQueue = [...offlineQueue, ...failed];
                            saveQueue();
                            showSyncNotification(`${processed} actions synced, ${failed.length} failed`);
                        }
                    });
            });
        }

        // Direct webhook call that returns a promise
        function callWebhookDirect(videoUrl, readStatus) {
            const webhookUrl = localStorage.getItem('learner_webhook_base_url');
            if (!webhookUrl) {
                console.warn('Webhook base URL not configured.');
                showOfflineNotification('Webhook URL missing. Configure in settings.');
                return Promise.reject('Webhook URL not configured');
            }

            return fetch(webhookUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: `mark video ${videoUrl} as ${readStatus === 1 ? 'read' : 'unread'}`
                })
            })
            .then(response => {
                if (response.ok) {
                    console.log('Webhook called successfully');
                    return response;
                } else {
                    console.error('Webhook call failed:', response.status);
                    const error = new Error(`HTTP ${response.status}`);
                    error.status = response.status;
                    throw error;
                }
            });
        }

        // Call webhook to update read status (with offline support)
        function callWebhook(videoUrl, readStatus) {
            if (!isOnline) {
                queueAction(videoUrl, readStatus);
                return;
            }

            callWebhookDirect(videoUrl, readStatus)
                .then(() => {
                    // Show sync notification immediately when task is completed online
                    showSyncNotification('Synced');
                })
                .catch(error => {
                    console.error('Error calling webhook:', error);

                    // Check if it's an internal server error (5xx)
                    if (error.status && error.status >= 500 && error.status < 600) {
                        // For internal server errors, show failed notification instead of queuing
                        console.log('Internal server error - not queuing request');
                        showSyncNotification('Failed');
                    } else {
                        // For other errors (network issues, 4xx errors), queue the request
                        queueAction(videoUrl, readStatus);
                    }
                });
        }

        // Show offline notification
        function showOfflineNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ff9800;
                color: white;
                padding: 12px 20px;
                border-radius: 4px;
                z-index: 1000;
                font-size: calc(0.9rem * var(--font-scale));
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        function showSyncNotification(message = 'Synced', duration = 1500) {
            // Remove any existing notification
            const existingNotification = document.querySelector('.sync-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // Create new notification
            const notification = document.createElement('div');
            notification.className = 'sync-notification';
            notification.textContent = message;
            document.body.appendChild(notification);

            // Show notification
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);

            // Hide and remove notification after duration
            if (duration > 0) {
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        notification.remove();
                    }, 300);
                }, duration);
            }
            return notification;
        }

        async function getAllPostsSync() {
            const data = await loadTabData('videos');
            if (!data.table || !data.table.rows) return [];

            const rows = data.table.rows;
            const cols = data.table.cols;
            const columnMap = {};
            cols.forEach((col, index) => {
                if (col.label) columnMap[col.label.toLowerCase()] = index;
            });

            let indices = {};
            indices.title = columnMap['video title'] ?? -1;
            indices.url = columnMap['video url'] ?? -1;
            indices.date = columnMap['added at'] ?? -1;
            indices.published = columnMap['published at'] ?? -1;
            indices.summary = columnMap['summary'] ?? -1;
            indices.read = columnMap['read'] ?? -1;

            return rows.map(row => {
                if (!row.c) return null;
                let title, videoUrl, addedAt, publishedAt, summary, isRead;

                title = indices.title >= 0 && row.c[indices.title] ? row.c[indices.title].v : '';
                videoUrl = indices.url >= 0 && row.c[indices.url] ? row.c[indices.url].v : '';
                addedAt = indices.date >= 0 && row.c[indices.date] ? row.c[indices.date].v : '';
                publishedAt = indices.published >= 0 && row.c[indices.published] ? row.c[indices.published].v : '';
                summary = indices.summary >= 0 && row.c[indices.summary] ? row.c[indices.summary].v : '';
                isRead = indices.read >= 0 && row.c[indices.read] ? (row.c[indices.read].v === 1 || row.c[indices.read].v === '1') : false;

                if (!summary || !summary.trim()) return null;
                const post = { title, videoUrl, addedAt, publishedAt, summary: summary.trim(), isRead, tabType: 'videos' };
                return post;
            }).filter(p => p !== null);
        }

        async function syncAllForOffline(limit = null) {
            const syncBtn = document.getElementById('sync-btn');

            // Get current active container
            const container = document.getElementById(`${currentTab}-container`);
            if (!container) return;

            // Find all unread posts
            const unreadPostElements = Array.from(container.querySelectorAll('.blog-post:not(.read)'));

            if (unreadPostElements.length === 0) {
                updateSyncStatusDisplay();
                return;
            }

            if (syncBtn) syncBtn.classList.add('syncing');

            try {
                // Fetch data for the current tab to map DOM elements to data objects
                const postsData = await getAllPostsSync();

                // Map elements to their corresponding data objects
                const postsToSyncRaw = unreadPostElements.map(el => {
                    const id = el.getAttribute('data-id');
                    return postsData.find(p => p.videoUrl === id);
                }).filter(p => p !== null);

                if (limit !== null) {
                    postsToSyncRaw.splice(limit);
                }

                // Filter out posts that are already in IndexedDB
                const needsSync = [];
                const cacheResults = await Promise.all(postsToSyncRaw.map(async post => {
                    const text = getPostSpeechText(post);
                    const useChinese = containsChinese(text);
                    const selectedVoice = useChinese ? GOOGLE_CLOUD_TTS_CONFIG.voice : GOOGLE_CLOUD_TTS_CONFIG.fallbackVoice;
                    const cacheKey = await hashText(text + selectedVoice.languageCode + selectedVoice.ssmlGender);
                    const cached = await AppCache.get(STORES.AUDIO, cacheKey);
                    return { post, isCached: cached && cached.status === 'done' };
                }));

                for (const res of cacheResults) {
                    if (!res.isCached) needsSync.push(res.post);
                }

                if (needsSync.length === 0) {
                    await updateAllPostsReadyStatus();
                    updateSyncStatusDisplay();
                    if (syncBtn) syncBtn.classList.remove('syncing');
                    return;
                }

                // Get global unread sync status for the button display
                const videos = await getAllPostsSync();
                const allUnreadPostsGlobal = videos.filter(p => {
                    // Check DOM first for most up-to-date local status
                    const postElement = document.querySelector(`[data-id="${p.videoUrl}"]`);
                    if (postElement) {
                        return !postElement.classList.contains('read');
                    }
                    return !p.isRead;
                });
                const totalUnreadCount = allUnreadPostsGlobal.length;

                // Calculate actual synced count globally
                const globalCacheChecks = await Promise.all(allUnreadPostsGlobal.map(async post => {
                    const text = getPostSpeechText(post);
                    const useChinese = containsChinese(text);
                    const voice = useChinese ? GOOGLE_CLOUD_TTS_CONFIG.voice : GOOGLE_CLOUD_TTS_CONFIG.fallbackVoice;
                    const cacheKey = await hashText(text + voice.languageCode + voice.ssmlGender);
                    const cached = await AppCache.get(STORES.AUDIO, cacheKey);
                    return cached && cached.status === 'done';
                }));
                let currentSyncedCount = globalCacheChecks.filter(x => x).length;

                // Function to update button text
                const updateButtonStatus = () => {
                    if (syncBtn) {
                        syncBtn.textContent = `Downloading: ${currentSyncedCount}/${totalUnreadCount}`;
                    }
                };

                updateButtonStatus();

                // Worker pool for parallel downloads (concurrency = 5)
                const CONCURRENCY = 5;
                let postIndex = 0;

                const worker = async () => {
                    while (postIndex < needsSync.length) {
                        const localIndex = postIndex++;
                        const post = needsSync[localIndex];
                        if (!post) continue;

                        try {
                            const text = getPostSpeechText(post);
                            const postId = post.videoUrl;
                            const postElement = document.querySelector(`[data-id="${postId}"]`);

                            // Start synthesis
                            const result = await synthesizeSpeech(text, post.title);

                            // Update border NOW to reflect 'in_progress' from cache
                            if (postElement) {
                                await updatePostReadyStatus(postElement);
                            }

                            // Wait for chunked processing if needed
                            if (result && typeof result === 'object' && result.isProcessing) {
                                await new Promise(resolve => {
                                    let waitTime = 0;
                                    const check = () => {
                                        if (!result.isProcessing || waitTime > 60000) resolve(); // 60s timeout
                                        else {
                                            waitTime += 200;
                                            setTimeout(check, 200);
                                        }
                                    };
                                    check();
                                });
                            }

                            currentSyncedCount++;
                            updateButtonStatus();

                            // Update border to READY (or what matches current cache)
                            if (postElement) {
                                await updatePostReadyStatus(postElement);
                            }

                            // Small buffer to avoid hitting API rate limits too hard
                            await new Promise(r => setTimeout(r, 100));
                        } catch (e) {
                            console.error('Failed to sync post:', e);
                        }
                    }
                };

                // Start workers
                const workersCount = Math.min(CONCURRENCY, needsSync.length);
                const workers = [];
                for (let i = 0; i < workersCount; i++) {
                    workers.push(worker());
                }

                await Promise.all(workers);


                // Final update
                await updateAllPostsReadyStatus();
                updateSyncStatusDisplay();
            } catch (error) {
                console.error('Sync failed:', error);
            } finally {
                if (syncBtn) syncBtn.classList.remove('syncing');
                updateSyncStatusDisplay();
            }
        }

        // Floating nav functionality
        function setupFloatingNav() {
            const floatingNav = document.getElementById('floating-nav');
            const prevBtn = document.getElementById('floating-prev');
            const markBtn = document.getElementById('floating-mark');
            const nextBtn = document.getElementById('floating-next');
            const prevPostBtn = document.getElementById('floating-prev-post');
            const nextPostBtn = document.getElementById('floating-next-post');

            if (!floatingNav || !prevBtn || !markBtn || !nextBtn || !prevPostBtn || !nextPostBtn) return;
            const bottomTabs = document.querySelector('.bottom-tabs');
            let scrollTimeout = null;

            function updateVisibility() {
                if (!floatingNav) return;
                const tabsHidden = bottomTabs && bottomTabs.classList.contains('hidden');
                floatingNav.classList.add('visible');
                floatingNav.classList.toggle('tabs-visible', !tabsHidden);
                updateFloatingMarkState();
            }

            function handleScroll() {
                updateVisibility();
            }

            window.addEventListener('scroll', handleScroll, { passive: true });
            window.addEventListener('resize', updateVisibility);

            // Initial check
            updateVisibility();

            prevBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (window.sharedAudio && window.sharedAudio.src) {
                    window.sharedAudio.currentTime = Math.max(0, window.sharedAudio.currentTime - 15);
                }
            });

            nextBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (window.sharedAudio && window.sharedAudio.src) {
                    window.sharedAudio.currentTime = Math.min(window.sharedAudio.duration || Infinity, window.sharedAudio.currentTime + 15);
                }
            });

            prevPostBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const current = getCurrentVisiblePost();
                if (current) {
                    const activeContainer = document.getElementById(`${currentTab}-container`);
                    const posts = Array.from(activeContainer.querySelectorAll('.blog-post'))
                        .filter(el => el.style.display !== 'none');
                    const idx = posts.indexOf(current);
                    if (idx > 0) {
                        const target = posts[idx - 1];
                        scrollToAdjacentPost(current, -1);
                        const listenBtn = target.querySelector('.listen-btn');
                        if (listenBtn) {
                            unlockAudio();
                            // Stop current if playing, then play target
                            stopAllPlayback();
                            setTimeout(() => toggleSpeech(listenBtn), 100);
                        }
                    }
                }
            });

            nextPostBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const current = getCurrentVisiblePost();
                const activeContainer = document.getElementById(`${currentTab}-container`);
                if (!activeContainer) return;

                const posts = Array.from(activeContainer.querySelectorAll('.blog-post'))
                    .filter(el => el.style.display !== 'none');

                let target = null;
                if (current) {
                    const idx = posts.indexOf(current);
                    if (idx !== -1 && idx < posts.length - 1) {
                        target = posts[idx + 1];
                        scrollToAdjacentPost(current, 1);
                    }
                } else {
                    target = posts[0];
                    if (target) {
                        const headerHeight = 70;
                        const rect = target.getBoundingClientRect();
                        window.scrollTo({ top: rect.top + window.scrollY - headerHeight + 5, behavior: 'smooth' });
                    }
                }

                if (target) {
                    const listenBtn = target.querySelector('.listen-btn');
                    if (listenBtn) {
                        unlockAudio();
                        stopAllPlayback();
                        setTimeout(() => toggleSpeech(listenBtn), 100);
                    }
                }
            });

            markBtn.addEventListener('click', (e) => {
                e.stopPropagation();

                const current = getCurrentVisiblePost();
                if (current) {
                    const listenBtn = current.querySelector('.listen-btn');
                    if (listenBtn) {
                        unlockAudio(); // CRITICAL: unlock audio on first click
                        toggleSpeech(listenBtn);
                        updateFloatingMarkState();
                        return;
                    }
                }

                // Fallback: pause any playing audio
                const allListenButtons = document.querySelectorAll('.listen-btn');
                for (const btn of allListenButtons) {
                    if (btn.speechState?.isPlaying && !btn.speechState?.isPaused) {
                        btn.click();
                        updateFloatingMarkState();
                        return;
                    }
                }
            });

            updateVisibility();
        }

        function updateFloatingMarkState() {
            const markBtn = document.getElementById('floating-mark');
            if (!markBtn) return;

            // Update header audio control based on current visible post
            updateHeaderAudioControl();

            const currentPost = getPostUnderHeader() || getCurrentVisiblePost();
            if (!currentPost) {
                markBtn.setAttribute('aria-label', 'Play audio');
                markBtn.title = 'Play audio';
                setFloatingMarkIcon(markBtn, 'play');
                return;
            }

            const listenBtn = currentPost.querySelector('.listen-btn');
            if (!listenBtn || !listenBtn.speechState) {
                markBtn.setAttribute('aria-label', 'Play audio');
                markBtn.title = 'Play audio';
                setFloatingMarkIcon(markBtn, 'play');
                return;
            }

            const { isPlaying, isPaused } = listenBtn.speechState;

            if (isPlaying && !isPaused) {
                markBtn.setAttribute('aria-label', 'Pause audio');
                markBtn.title = 'Pause audio';
                setFloatingMarkIcon(markBtn, 'pause');
            } else {
                markBtn.setAttribute('aria-label', isPaused ? 'Resume audio' : 'Play audio');
                markBtn.title = isPaused ? 'Resume audio' : 'Play audio';
                setFloatingMarkIcon(markBtn, 'play');
            }
        }

        function getPostUnderHeader() {
            const scrollTop = window.pageYOffset;
            if (scrollTop <= 100) return null;

            const activeContainer = document.getElementById(`${currentTab}-container`);
            if (!activeContainer) return null;

            const posts = activeContainer.querySelectorAll('.blog-post');
            const headerHeight = 70; // Header height with padding
            const headerBottomPosition = scrollTop + headerHeight;

            for (let i = 0; i < posts.length; i++) {
                const post = posts[i];
                const postTop = post.offsetTop;
                const postBottom = postTop + post.offsetHeight;

                if (headerBottomPosition >= postTop && headerBottomPosition <= postBottom) {
                    return post;
                }
            }
            return null;
        }

        // Update header audio control state based on current visible post
        function updateHeaderAudioControl() {
            const headerControl = document.getElementById('header-audio-control');
            const headerBtn = document.getElementById('header-audio-btn');
            const headerTitle = document.getElementById('header-title');
            if (!headerBtn || !headerControl) return;

            // Hide action control when header shows "Learner" (no post title)
            const isShowingPostTitle = headerTitle && headerTitle.textContent !== 'Learner';
            if (!isShowingPostTitle) {
                headerControl.style.display = 'none';
                headerBtn._currentPost = null;
                return;
            }
            headerControl.style.display = 'flex';

            // Get the current post under the header
            const currentPost = getPostUnderHeader();
            headerBtn._currentPost = currentPost;

            if (!currentPost) {
                headerBtn.style.opacity = '0.5';
                headerBtn.title = 'Mark as read';
                setHeaderAudioIcon(headerBtn, 'check');
                return;
            }

            headerBtn.style.opacity = '1';
            const isRead = currentPost.classList.contains('read');
            headerBtn.title = isRead ? 'Mark as unread' : 'Mark as read';
            setHeaderAudioIcon(headerBtn, 'check');
        }

        function setHeaderAudioIcon(btn, type) {
            if (type === 'check') {
                btn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" xmlns="http://www.w3.org/2000/svg">
                        <path d="M5 13l4 4L19 7" stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                `;
            } else if (type === 'pause') {
                btn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="6" y="4" width="4" height="16" fill="currentColor"/>
                        <rect x="14" y="4" width="4" height="16" fill="currentColor"/>
                    </svg>
                `;
            } else {
                btn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 20 22" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="5,3 19,12 5,21" stroke="currentColor" stroke-width="2" fill="none"/>
                    </svg>
                `;
            }
        }

        function setFloatingMarkIcon(markBtn, type) {
            if (type === 'pause') {
                markBtn.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <rect x="7" y="5" width="2.5" height="14" rx="1" />
                        <rect x="14.5" y="5" width="2.5" height="14" rx="1" />
                    </svg>
                `;
            } else {
                markBtn.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path d="M8 5v14l11-7z" stroke="none" />
                    </svg>
                `;
            }
        }

        function getCurrentVisiblePost() {
            const activeContainer = document.getElementById(`${currentTab}-container`);
            if (!activeContainer) return null;

            // Filter only visible posts
            const posts = Array.from(activeContainer.querySelectorAll('.blog-post'))
                .filter(el => el.style.display !== 'none');

            if (!posts.length) return null;

            const headerHeight = 70;
            const threshold = window.scrollY + headerHeight + 5;

            // Find post that is spanning across the threshold (at the top under header)
            for (const post of posts) {
                const rect = post.getBoundingClientRect();
                const postTop = rect.top + window.scrollY;
                const postBottom = postTop + rect.height;
                if (threshold >= postTop && threshold <= postBottom) {
                    return post;
                }
            }

            // Fallback: if we are at the very top, return the first post
            if (window.scrollY < 100) return posts[0];

            // Second Fallback: find any post that is visible in viewport
            const firstInView = posts.find(post => {
                const rect = post.getBoundingClientRect();
                return rect.top >= 0 && rect.top <= window.innerHeight;
            });

            if (firstInView) return firstInView;

            // Third Fallback: use closest to middle (legacy logic)
            const viewportMiddle = window.scrollY + window.innerHeight / 2;
            return posts.reduce((closest, post) => {
                const rect = post.getBoundingClientRect();
                const postMiddle = rect.top + window.scrollY + rect.height / 2;
                const distance = Math.abs(postMiddle - viewportMiddle);
                if (!closest || distance < closest.distance) {
                    return { element: post, distance };
                }
                return closest;
            }, null)?.element || posts[0];
        }

        function scrollToAdjacentPost(currentPostDiv, direction) {
            if (!currentPostDiv || typeof direction !== 'number') return;
            const activeContainer = document.getElementById(`${currentTab}-container`);
            if (!activeContainer) return;

            // Get only visible posts
            const posts = Array.from(activeContainer.querySelectorAll('.blog-post'))
                .filter(el => el.style.display !== 'none');

            if (!posts.length) return;
            const currentIndex = posts.indexOf(currentPostDiv);

            const targetIndex = currentIndex + direction;
            if (targetIndex >= 0 && targetIndex < posts.length) {
                const target = posts[targetIndex];
                const headerHeight = 70;

                // Get absolute top using getBoundingClientRect for reliability
                const rect = target.getBoundingClientRect();
                const absoluteTop = rect.top + window.scrollY;
                const offset = absoluteTop - headerHeight + 5;

                window.scrollTo({
                    top: Math.max(0, offset),
                    behavior: 'smooth'
                });
            }
        }

        // Collapse/Expand all functionality
        function setupCollapseAll() {
            const collapseAllBtn = document.getElementById('collapse-all-btn');
            let allCollapsed = false;

            function updateIcon() {
                const svg = collapseAllBtn.querySelector('svg');
                const path = svg.querySelector('path');

                if (allCollapsed) {
                    // Show down arrow for expand
                    path.setAttribute('d', 'M6 9L12 15L18 9');
                    collapseAllBtn.setAttribute('title', 'Expand All');
                } else {
                    // Show up arrow for collapse
                    path.setAttribute('d', 'M18 15L12 9L6 15');
                    collapseAllBtn.setAttribute('title', 'Collapse All');
                }
            }

            collapseAllBtn.addEventListener('click', function() {
                // Get current tab container
                const currentContainer = document.getElementById(`${currentTab}-container`);
                const posts = currentContainer.querySelectorAll('.blog-post');

                if (allCollapsed) {
                    // Expand all
                    posts.forEach(post => {
                        post.classList.remove('collapsed');
                    });
                    allCollapsed = false;
                } else {
                    // Collapse all
                    posts.forEach(post => {
                        post.classList.add('collapsed');
                    });
                    allCollapsed = true;
                }

                updateIcon();
                // Trigger floating nav visibility update
                window.dispatchEvent(new Event('resize'));
            });

            // Initialize with correct icon
            updateIcon();
        }

        // Text highlighting functionality
        function setupTextHighlighting() {
            let tooltip = null;

            document.addEventListener('mouseup', function(e) {
                // Small delay to ensure selection is complete
                setTimeout(() => {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();

                    // Remove existing tooltip
                    if (tooltip) {
                        tooltip.remove();
                        tooltip = null;
                    }

                    // Only show tooltip if text is selected and it's within post content
                    if (selectedText && selection.rangeCount > 0 && selectedText.length > 2) {
                        const range = selection.getRangeAt(0);
                        const container = range.commonAncestorContainer;

                        // Check if selection is within post content
                        let element = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
                        const postContent = element.closest('.post-content');

                        console.log('Post content found:', !!postContent); // Debug log

                        if (postContent) {
                            showHighlightTooltip(range);
                        }
                    }
                }, 10);
            });

            // Hide tooltip when clicking elsewhere
            document.addEventListener('mousedown', function(e) {
                if (tooltip && !tooltip.contains(e.target)) {
                    tooltip.remove();
                    tooltip = null;
                }
            });

            function showHighlightTooltip(range) {
                tooltip = document.createElement('div');
                tooltip.className = 'highlight-tooltip';
                tooltip.textContent = 'Highlight';

                // Position tooltip above the selection
                const rect = range.getBoundingClientRect();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

                tooltip.style.position = 'absolute';
                tooltip.style.left = Math.max(10, rect.left + rect.width / 2) + 'px';
                tooltip.style.top = (rect.top + scrollTop - 45) + 'px';
                tooltip.style.transform = 'translateX(-50%)';

                console.log('Tooltip positioned at:', tooltip.style.left, tooltip.style.top); // Debug log

                document.body.appendChild(tooltip);

                tooltip.addEventListener('click', function() {
                    highlightSelection(range);
                    tooltip.remove();
                    tooltip = null;
                    window.getSelection().removeAllRanges();
                });
            }

            function highlightSelection(range) {
                try {
                    // Check if selection spans across different block elements (like list items)
                    const startContainer = range.startContainer;
                    const endContainer = range.endContainer;

                    // Get the closest block elements
                    const startBlock = getClosestBlockElement(startContainer);
                    const endBlock = getClosestBlockElement(endContainer);

                    // If selection spans across different block elements, highlight each separately
                    if (startBlock !== endBlock) {
                        console.log('Selection spans across different block elements, highlighting each separately');
                        highlightAcrossBlocks(range);
                        return;
                    }

                    // Check if we're inside a list item and the selection is complex
                    const listItem = range.commonAncestorContainer.nodeType === Node.TEXT_NODE ?
                        range.commonAncestorContainer.parentElement.closest('li') :
                        range.commonAncestorContainer.closest('li');

                    if (listItem) {
                        // For list items, use a safer highlighting approach
                        highlightInListItem(range);
                    } else {
                        // Standard highlighting for regular text
                        const contents = range.extractContents();
                        const span = document.createElement('span');
                        span.className = 'highlight';
                        span.appendChild(contents);
                        range.insertNode(span);

                        addRemoveHighlightHandler(span);
                    }
                } catch (error) {
                    console.error('Error highlighting text:', error);
                }
            }

            function highlightAcrossBlocks(range) {
                // Get all text nodes within the selection
                const walker = document.createTreeWalker(
                    range.commonAncestorContainer,
                    NodeFilter.SHOW_TEXT,
                    {
                        acceptNode: function(node) {
                            // Only include text nodes that are within the selection
                            const nodeRange = document.createRange();
                            nodeRange.selectNodeContents(node);

                            // Check if this text node intersects with our selection
                            if (range.intersectsNode(node)) {
                                return NodeFilter.FILTER_ACCEPT;
                            }
                            return NodeFilter.FILTER_REJECT;
                        }
                    }
                );

                const textNodes = [];
                let node;
                while (node = walker.nextNode()) {
                    textNodes.push(node);
                }

                // Process each text node that intersects with the selection
                textNodes.forEach(textNode => {
                    const blockElement = getClosestBlockElement(textNode);
                    if (!blockElement) return;

                    // Create a range for this specific text node
                    const nodeRange = document.createRange();
                    nodeRange.selectNodeContents(textNode);

                    // Find the intersection with the original selection
                    const intersectionRange = document.createRange();

                    // Determine start and end points for this text node
                    let startOffset = 0;
                    let endOffset = textNode.textContent.length;

                    // If this is the start node, use the selection's start offset
                    if (textNode === range.startContainer) {
                        startOffset = range.startOffset;
                    }

                    // If this is the end node, use the selection's end offset
                    if (textNode === range.endContainer) {
                        endOffset = range.endOffset;
                    }

                    // Only highlight if there's actual text to highlight
                    if (startOffset < endOffset) {
                        intersectionRange.setStart(textNode, startOffset);
                        intersectionRange.setEnd(textNode, endOffset);

                        // Highlight this portion
                        highlightSingleRange(intersectionRange);
                    }
                });
            }

            function highlightSingleRange(range) {
                try {
                    const contents = range.extractContents();
                    const span = document.createElement('span');
                    span.className = 'highlight';
                    span.appendChild(contents);
                    range.insertNode(span);

                    addRemoveHighlightHandler(span);
                } catch (error) {
                    console.error('Error highlighting single range:', error);
                }
            }

            function getClosestBlockElement(node) {
                const blockElements = ['P', 'DIV', 'LI', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'BLOCKQUOTE'];
                let current = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;

                while (current && current !== document.body) {
                    if (blockElements.includes(current.tagName)) {
                        return current;
                    }
                    current = current.parentElement;
                }
                return null;
            }

            function highlightInListItem(range) {
                // For list items, we'll wrap the text more carefully
                const selection = range.toString();
                const startOffset = range.startOffset;
                const endOffset = range.endOffset;
                const container = range.startContainer;

                if (container.nodeType === Node.TEXT_NODE && range.startContainer === range.endContainer) {
                    // Simple case: selection within a single text node
                    const textNode = container;
                    const beforeText = textNode.textContent.substring(0, startOffset);
                    const selectedText = textNode.textContent.substring(startOffset, endOffset);
                    const afterText = textNode.textContent.substring(endOffset);

                    // Create new nodes
                    const beforeNode = document.createTextNode(beforeText);
                    const highlightSpan = document.createElement('span');
                    highlightSpan.className = 'highlight';
                    highlightSpan.textContent = selectedText;
                    const afterNode = document.createTextNode(afterText);

                    // Replace the original text node
                    const parent = textNode.parentNode;
                    parent.insertBefore(beforeNode, textNode);
                    parent.insertBefore(highlightSpan, textNode);
                    parent.insertBefore(afterNode, textNode);
                    parent.removeChild(textNode);

                    addRemoveHighlightHandler(highlightSpan);
                } else {
                    console.log('Complex list selection, skipping highlight to preserve structure');
                }
            }

            function addRemoveHighlightHandler(span) {
                span.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const parent = span.parentNode;
                    const textContent = span.textContent;
                    const textNode = document.createTextNode(textContent);
                    parent.replaceChild(textNode, span);
                    parent.normalize(); // Merge adjacent text nodes
                });
            }
        }


        // Header title update functionality
        function setupHeaderTitleUpdate() {
            const headerTitle = document.getElementById('header-title');
            const headerMenu = document.getElementById('header-menu');
            let currentPost = null;
            const originalTitle = 'Learner';

            window.addEventListener('scroll', function() {
                const scrollTop = window.pageYOffset;
                const currentPost = getPostUnderHeader();

                // Update header title and settings icon visibility based on current post
                if (currentPost) {
                    const titleElement = currentPost.querySelector('.post-title');
                    if (titleElement) {
                        const postTitle = titleElement.textContent || titleElement.innerText;
                        headerTitle.textContent = postTitle;
                        headerMenu.style.display = 'none'; // Hide settings icon
                    }
                } else {
                    headerTitle.textContent = originalTitle;
                    headerMenu.style.display = 'flex'; // Show settings icon
                }

                // Ensure header audio control is also updated and synced
                updateFloatingMarkState();
            });

            // Click handler for header title to scroll to current post
            headerTitle.addEventListener('click', function() {
                if (currentPost && headerTitle.textContent !== originalTitle) {
                    const headerHeight = 70; // Header height with padding
                    const offset = currentPost.offsetTop - headerHeight;
                    window.scrollTo({
                        top: offset,
                        behavior: 'smooth'
                    });
                }
            });
        }

        // Reset header title to default when switching tabs
        function resetHeaderTitle() {
            const headerTitle = document.getElementById('header-title');
            const headerMenu = document.getElementById('header-menu');
            const originalTitle = 'Learner';

            headerTitle.textContent = originalTitle;
            headerMenu.style.display = 'flex'; // Show settings icon

            // Sync audio controls
            updateHeaderAudioControl();
        }

        // Sync functionality is now handled in hamburger menu

        // Google Cloud Text-to-Speech API configuration
        const GOOGLE_CLOUD_TTS_CONFIG = {
            apiKey: localStorage.getItem('googleCloudTTSApiKey') || '', // Google Cloud API key from settings
            endpoint: 'https://texttospeech.googleapis.com/v1/text:synthesize',
            maxTextBytes: 4000, // Use chunking for text over this limit
            voice: {
                languageCode: 'zh-CN',
                ssmlGender: 'FEMALE'
            },
            fallbackVoice: {
                languageCode: 'en-US',
                ssmlGender: 'FEMALE'
            },
            audioConfig: {
                audioEncoding: 'MP3',
                speakingRate: 1.2,
                pitch: 0.0,
                volumeGainDb: 0.0
            }
        };

        // Speech synthesis functionality using Google Cloud TTS with streaming support
        function getCleanTextFromSummary(summary) {
            if (!summary) return '';
            const tempDiv = document.createElement('div');
            try {
                // Parse markdown and remove tables
                tempDiv.innerHTML = marked.parse(summary);
                const tables = tempDiv.querySelectorAll('table');
                tables.forEach(table => table.remove());

                // Remove the first H1 if present (it's often the title)
                const firstH1 = tempDiv.querySelector('h1');
                if (firstH1) firstH1.remove();
            } catch (e) {
                tempDiv.innerHTML = summary;
            }
            return (tempDiv.textContent || tempDiv.innerText || '').trim();
        }

        function getPostSpeechText(post) {
            const title = post.title || 'Untitled';
            const cleanContent = getCleanTextFromSummary(post.summary);
            return `Overview. ${title}. ${cleanContent}`;
        }

        function getSpeechText(button) {
            if (button.postData) {
                return getPostSpeechText(button.postData);
            }
            // Fallback to DOM-based extraction if postData is missing
            const postElement = button.closest('.blog-post');
            const title = postElement.querySelector('.post-title').innerText;
            const contentDiv = postElement.querySelector('.post-content');
            let textToSpeak = `Overview. ${title}.`;

            if (contentDiv) {
                const contentClone = contentDiv.cloneNode(true);
                const tables = contentClone.querySelectorAll('table');
                tables.forEach(table => table.remove());
                const contentText = contentClone.textContent || contentClone.innerText || '';
                textToSpeak = `Overview. ${title}. ${contentText.trim()}`;
            }
            return textToSpeak;
        }

        async function preloadSpeech(button) {
            const speechState = button.speechState;
            if (!speechState || speechState.preloadedResult || speechState.audio || speechState.audioQueueManager || speechState.isLoading) return;

            // Check if API key is configured
            if (!GOOGLE_CLOUD_TTS_CONFIG.apiKey) return;

            try {
                speechState.isLoading = true;
                const textToSpeak = getSpeechText(button);
                const audioResult = await synthesizeSpeech(textToSpeak);
                speechState.preloadedResult = audioResult;
                console.log('Preloaded audio for:', button.closest('.blog-post').querySelector('.post-title')?.textContent);
            } catch (e) {
                console.error('Preload failed:', e);
            } finally {
                speechState.isLoading = false;
            }
        }

        function preloadNextPostAudio(currentPostDiv) {
            const container = currentPostDiv.parentElement;
            if (!container) return;
            const allPosts = Array.from(container.querySelectorAll('.blog-post'));
            const currentIndex = allPosts.indexOf(currentPostDiv);

            if (currentIndex >= 0 && currentIndex < allPosts.length - 1) {
                const nextPost = allPosts[currentIndex + 1];
                const nextListenBtn = nextPost.querySelector('.listen-btn');
                if (nextListenBtn) {
                    preloadSpeech(nextListenBtn);
                }
            }
        }

        async function toggleSpeech(button) {
            const speechState = button.speechState;

            // If already loading (from preload), wait for it to finish then continue
            if (speechState.isLoading && !speechState.preloadedResult) {
                console.log('Play requested while preloading... waiting');
                // Show loading state while waiting
                button.classList.add('loading');
                button.innerHTML = `
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" stroke-dasharray="31.416" stroke-dashoffset="31.416">
                            <animate attributeName="stroke-dasharray" dur="2s" values="0 31.416;15.708 15.708;0 31.416" repeatCount="indefinite"/>
                            <animate attributeName="stroke-dashoffset" dur="2s" values="0;-15.708;-31.416" repeatCount="indefinite"/>
                        </circle>
                    </svg>
                `;

                // Wait up to 15 seconds for preload
                let waitTime = 0;
                while (speechState.isLoading && !speechState.preloadedResult && waitTime < 15000) {
                    await new Promise(r => setTimeout(r, 100));
                    waitTime += 100;
                }
                console.log('Wait finished, status:', { loaded: !!speechState.preloadedResult, time: waitTime });
            }

            // Stop all other playing audio first
            stopAllOtherAudio(button);
            window.currentAudioButton = button;

            if (speechState.isPlaying) {
                // Track play time before pausing
                if (speechState.lastPlayStartTime) {
                    speechState.totalPlayTime += (performance.now() - speechState.lastPlayStartTime) / 1000;
                    speechState.lastPlayStartTime = null;
                }

                // Pause current audio (works for both single and streaming audio)
                if (speechState.audioQueueManager) {
                    // Streaming audio
                    speechState.audioQueueManager.pause();
                } else if (speechState.audio) {
                    // Single chunk audio
                    speechState.audio.pause();
                }

                speechState.isPlaying = false;
                speechState.isPaused = true;
                button.classList.remove('playing');
                button.classList.add('paused');
                button.innerHTML = `
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="5,3 19,12 5,21" stroke="currentColor" stroke-width="2" fill="none"/>
                    </svg>
                `;
                updateFloatingMarkState();
                updateMediaSession(button);
            } else if (speechState.isPaused) {
                // Track start time on resume
                speechState.lastPlayStartTime = performance.now();

                // Resume paused audio (works for both single and streaming audio)
                if (speechState.audioQueueManager) {
                    // Streaming audio
                    await speechState.audioQueueManager.resume();
                } else if (speechState.audio) {
                    // Single chunk audio
                    await speechState.audio.play();
                }

                speechState.isPlaying = true;
                speechState.isPaused = false;
                button.classList.remove('paused');
                button.classList.add('playing');
                button.innerHTML = `
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="6" y="4" width="4" height="16" fill="currentColor"/>
                        <rect x="14" y="4" width="4" height="16" fill="currentColor"/>
                    </svg>
                `;
                updateFloatingMarkState();
                updateMediaSession(button);
            } else {
                // Check if API key is configured
                if (!GOOGLE_CLOUD_TTS_CONFIG.apiKey) {
                    alert('Please configure your Google Cloud Text-to-Speech API key in the GOOGLE_CLOUD_TTS_CONFIG object.');
                    return;
                }

                const postElement = button.closest('.blog-post');
                const contentDiv = postElement.querySelector('.post-content');

                // iOS/Safari: Prime the shared audio object inside the user-gestured click event
                // This is CRITICAL for iOS to allow the later async play() call.
                const audio = getSharedAudio();
                try {
                    // Start a silent play immediately to "harness" the user gesture
                    // We don't bother with .then() here, just trigger it
                    audio.play().catch(() => {});
                    audio.pause();
                } catch (e) {
                    console.warn('Silent priming failed:', e);
                }

                // Set up text tracking for scroll-along feature
                if (contentDiv) {
                    setupTextTracking(contentDiv);
                    speechState.contentDiv = contentDiv;
                    // Highlight first segment immediately
                    highlightSegment(contentDiv, 0);
                }

                try {
                    let audioResult;

                    if (speechState.preloadedResult) {
                        console.log('Using preloaded audio result');
                        audioResult = speechState.preloadedResult;
                        speechState.preloadedResult = null;
                    } else {
                        speechState.isLoading = true;
                        const textToSpeak = getSpeechText(button);

                        // Update button to loading state
                        button.classList.add('loading');
                        button.innerHTML = `
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" stroke-dasharray="31.416" stroke-dashoffset="31.416">
                                    <animate attributeName="stroke-dasharray" dur="2s" values="0 31.416;15.708 15.708;0 31.416" repeatCount="indefinite"/>
                                    <animate attributeName="stroke-dashoffset" dur="2s" values="0;-15.708;-31.416" repeatCount="indefinite"/>
                                </circle>
                            </svg>
                        `;

                        audioResult = await synthesizeSpeech(textToSpeak, postElement.querySelector('.post-title')?.textContent);
                    }

                    // Check if this is a streaming result (multiple chunks) or single audio
                    if (audioResult && audioResult.totalChunks && audioResult.totalChunks > 1 && !audioResult.mergedContent) {
                        // Streaming audio with multiple chunks
                        console.log(`Starting streaming playback with ${audioResult.totalChunks} chunks`);

                        const audioQueueManager = new AudioQueueManager(audioResult, button, contentDiv);
                        speechState.audioQueueManager = audioQueueManager;
                        speechState.audio = null; // Clear single audio reference

                        // Update button state and start tracking time
                        speechState.totalPlayTime = 0; // Reset
                        speechState.isPlaying = true;
                        speechState.isPaused = false;
                        button.classList.remove('loading');
                        button.classList.add('playing');
                        button.innerHTML = `
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <rect x="6" y="4" width="4" height="16" fill="currentColor"/>
                                <rect x="14" y="4" width="4" height="16" fill="currentColor"/>
                            </svg>
                        `;

                        // Update floating mark button to show pause icon
                        updateFloatingMarkState();
                        updateMediaSession(button);

                        // Start streaming playback
                        await audioQueueManager.playFirstChunk();

                    } else if (audioResult) {
                        // Single chunk audio (original behavior) or merged streaming audio
                        const audioContent = audioResult.mergedContent || audioResult.firstChunk || audioResult;

                        if (!audioContent) {
                            throw new Error('No audio content received from synthesis');
                        }

                        // Use shared audio player
                        const audio = getSharedAudio();
                        audio.src = `data:audio/mpeg;base64,${audioContent}`;
                        audio.playbackRate = window.currentPlaybackSpeed || 1.0;

                        // Update button state and start tracking time
                        speechState.totalPlayTime = 0;
                        speechState.lastPlayStartTime = performance.now();

                        speechState.audio = audio;
                        speechState.audioQueueManager = null; // Clear streaming reference
                        speechState.isPlaying = true;
                        speechState.isPaused = false;
                        button.classList.remove('loading');
                        button.classList.add('playing');
                        button.innerHTML = `
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <rect x="6" y="4" width="4" height="16" fill="currentColor"/>
                                <rect x="14" y="4" width="4" height="16" fill="currentColor"/>
                            </svg>
                        `;

                        // Update floating mark button to show pause icon
                        updateFloatingMarkState();
                        updateMediaSession(button);

                        // Set up text tracking for single audio
                        if (contentDiv && contentDiv._totalChars) {
                            let lastSegmentIndex = -1;
                            audio.ontimeupdate = function() {
                                const charPos = estimateCharPosition(
                                    audio.currentTime,
                                    audio.duration,
                                    contentDiv._totalChars,
                                    audio.playbackRate
                                );
                                const segmentIndex = findSegmentByCharPosition(contentDiv, charPos);
                                if (segmentIndex !== lastSegmentIndex) {
                                    lastSegmentIndex = segmentIndex;
                                    highlightSegment(contentDiv, segmentIndex);
                                }
                            };
                        }

                        // Handle audio end
                        audio.onended = function() {
                            if (speechState.lastPlayStartTime) {
                                speechState.totalPlayTime += (performance.now() - speechState.lastPlayStartTime) / 1000;
                                speechState.lastPlayStartTime = null;
                            }
                            updateAudioMinutes(button, speechState.totalPlayTime);

                            clearTextTracking(contentDiv);
                            resetButton(button);
                            updateFloatingMarkState();
                            // Auto mark as read when audio finishes
                            autoMarkPostAsRead(button);
                            // Auto play next post if continuous play is enabled
                            autoContinuousPlay(button);
                        };

                        // Start playing
                        try {
                            await audio.play();
                        } catch (playError) {
                            if (playError.name === 'NotAllowedError') {
                                throw new Error('Autoplay blocked. Please click the play button manually.');
                            }
                            throw playError;
                        }
                    }

                } catch (error) {
                    console.error('Text-to-speech playback error:', error);
                    button.classList.remove('loading');
                    resetButton(button);

                    const errorMsg = error.message || 'Unknown network error';
                    if (errorMsg.includes('API key')) {
                        alert('Failed to generate speech. Please check your Google Cloud TTS API key in settings.');
                    } else if (errorMsg.includes('quota') || errorMsg.includes('429')) {
                        alert('TTS Quota exceeded or too many requests. Please try again in a moment.');
                    } else if (errorMsg.includes('Autoplay blocked') || errorMsg.includes('not allowed')) {
                        alert('Autoplay blocked by your browser. Please click Play once to enable continuous playback.');
                    } else {
                        alert(`Playback error: ${errorMsg}`);
                    }
                } finally {
                    speechState.isLoading = false;
                }
            }
        }

        // Function to detect if text contains Chinese characters
        function containsChinese(text) {
            return /[\u4e00-\u9fff]/.test(text);
        }

        // Text tracking for audio playback - wraps content in trackable segments
        function setupTextTracking(contentDiv) {
            // Skip if already set up
            if (contentDiv.dataset.trackingSetup === 'true') {
                return getTrackingSegments(contentDiv);
            }

            const segments = [];
            let segmentIndex = 0;

            // Process all text-containing elements (paragraphs, list items, headings)
            const textElements = contentDiv.querySelectorAll('p, li, h1, h2, h3, h4, h5, h6, blockquote');

            textElements.forEach(element => {
                // Skip elements inside tables
                if (element.closest('table')) return;

                // Get the text content for tracking
                const text = element.textContent.trim();
                if (!text) return;

                // Wrap the element content in a tracking span
                const wrapper = document.createElement('span');
                wrapper.className = 'speech-tracking-segment';
                wrapper.dataset.segmentIndex = segmentIndex;
                wrapper.dataset.segmentText = text;

                // Move all children into the wrapper
                while (element.firstChild) {
                    wrapper.appendChild(element.firstChild);
                }
                element.appendChild(wrapper);

                segments.push({
                    index: segmentIndex,
                    element: wrapper,
                    text: text,
                    charStart: segmentIndex === 0 ? 0 : segments[segmentIndex - 1].charEnd,
                    charEnd: 0 // Will be calculated below
                });
                segmentIndex++;
            });

            // Calculate character positions for each segment
            let totalChars = 0;
            segments.forEach(segment => {
                segment.charStart = totalChars;
                totalChars += segment.text.length;
                segment.charEnd = totalChars;
            });

            contentDiv.dataset.trackingSetup = 'true';
            contentDiv._trackingSegments = segments;
            contentDiv._totalChars = totalChars;

            return segments;
        }

        // Get existing tracking segments
        function getTrackingSegments(contentDiv) {
            return contentDiv._trackingSegments || [];
        }

        // Highlight current segment and scroll to it
        function highlightSegment(contentDiv, segmentIndex) {
            const segments = getTrackingSegments(contentDiv);

            // Remove highlight from all segments
            segments.forEach(seg => {
                seg.element.classList.remove('current-speech');
            });

            // Add highlight to current segment
            if (segmentIndex >= 0 && segmentIndex < segments.length) {
                const currentSegment = segments[segmentIndex];
                currentSegment.element.classList.add('current-speech');

                // Scroll to the segment smoothly
                currentSegment.element.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });
            }
        }

        // Find segment index based on character position
        function findSegmentByCharPosition(contentDiv, charPosition) {
            const segments = getTrackingSegments(contentDiv);

            for (let i = 0; i < segments.length; i++) {
                if (charPosition >= segments[i].charStart && charPosition < segments[i].charEnd) {
                    return i;
                }
            }

            // Return last segment if position is beyond all segments
            return segments.length - 1;
        }

        // Clear all text tracking highlights
        function clearTextTracking(contentDiv) {
            if (!contentDiv) return;

            const segments = getTrackingSegments(contentDiv);
            segments.forEach(seg => {
                seg.element.classList.remove('current-speech');
            });
        }

        // Estimate character position based on audio time
        // Uses average speaking rate of ~150 words per minute (~12.5 chars/second for English)
        function estimateCharPosition(currentTime, duration, totalChars, playbackRate = 1.0) {
            if (duration <= 0) return 0;

            // Calculate progress through the audio
            const progress = currentTime / duration;

            // Estimate character position based on progress
            return Math.floor(progress * totalChars);
        }

        // Function to extract YouTube video ID from URL
        function extractYouTubeVideoId(url) {
            if (!url) return null;

            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
                /youtube\.com\/watch\?.*v=([^&\n?#]+)/
            ];

            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) {
                    return match[1];
                }
            }
            return null;
        }

        // Function to create YouTube embed iframe with error handling
        function createYouTubeEmbed(videoUrl) {
            const videoId = extractYouTubeVideoId(videoUrl);
            if (!videoId) return null;

            const embedContainer = document.createElement('div');
            embedContainer.className = 'youtube-embed-container';

            // Create iframe with error handling
            const iframe = document.createElement('iframe');
            iframe.src = `https://www.youtube.com/embed/${videoId}?enablejsapi=1&origin=${window.location.origin}&playsinline=1&rel=0&modestbranding=1&fs=1&controls=1`;
            iframe.frameBorder = '0';
            iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
            iframe.allowFullscreen = true;
            iframe.loading = 'lazy';
            iframe.title = 'YouTube video player';
            iframe.sandbox = 'allow-scripts allow-same-origin allow-presentation allow-forms allow-popups allow-popups-to-escape-sandbox';

            // Add error handling for iframe load failures
            iframe.onerror = function() {
                console.warn('YouTube embed failed, creating fallback link');
                createYouTubeFallback(embedContainer, videoUrl, videoId);
            };

            // Also listen for load event to check if embed is blocked
            iframe.onload = function() {
                // Small delay to check if the iframe content loaded properly
                setTimeout(() => {
                    try {
                        // If we can't access the iframe content, it might be blocked
                        if (iframe.contentWindow && iframe.contentWindow.location.href === 'about:blank') {
                            console.warn('YouTube embed may be blocked, showing fallback');
                            createYouTubeFallback(embedContainer, videoUrl, videoId);
                        }
                    } catch (e) {
                        // Cross-origin error is expected, iframe is working
                    }
                }, 1000);
            };

            embedContainer.appendChild(iframe);
            return embedContainer;
        }

        // Function to create fallback YouTube link when embed fails
        function createYouTubeFallback(container, videoUrl, videoId) {
            // Clear the container
            container.innerHTML = '';

            // Create fallback link with thumbnail
            const fallbackDiv = document.createElement('div');
            fallbackDiv.className = 'youtube-fallback';
            fallbackDiv.innerHTML = `
                <div class="youtube-thumbnail-container">
                    <img src="https://img.youtube.com/vi/${videoId}/maxresdefault.jpg"
                         alt="YouTube video thumbnail"
                         class="youtube-thumbnail"
                         onerror="this.src='https://img.youtube.com/vi/${videoId}/hqdefault.jpg'">
                    <div class="youtube-play-overlay">
                        <svg width="68" height="48" viewBox="0 0 68 48">
                            <path d="M66.52,7.74c-0.78-2.93-2.49-5.41-5.42-6.19C55.79,.13,34,0,34,0S12.21,.13,6.9,1.55 C3.97,2.33,2.27,4.81,1.48,7.74C0.06,13.05,0,24,0,24s0.06,10.95,1.48,16.26c0.78,2.93,2.49,5.41,5.42,6.19 C12.21,47.87,34,48,34,48s21.79-0.13,27.1-1.55c2.93-0.78,4.64-3.26,5.42-6.19C67.94,34.95,68,24,68,24S67.94,13.05,66.52,7.74z" fill="#f00"></path>
                            <path d="M 45,24 27,14 27,34" fill="#fff"></path>
                        </svg>
                    </div>
                    <a href="${videoUrl}" target="_blank" rel="noopener noreferrer" class="youtube-fallback-link">
                        Watch on YouTube
                    </a>
                </div>
            `;

            container.appendChild(fallbackDiv);
        }

        // Function to update the audio minutes in the post header
        function updateAudioMinutes(button, durationSeconds) {
            if (!durationSeconds || durationSeconds <= 0) return;

            const playbackRate = window.currentPlaybackSpeed || 1.0;
            // if it actually took 10 minutes to play and play speed is 2x then the audio time is 20 minutes
            const contentMinutes = (durationSeconds * playbackRate) / 60;
            const contentMinutesRounded = Math.ceil(contentMinutes);

            // Find the reading-time span in the post header
            const postHeader = button.closest('.post-header');
            if (postHeader) {
                const readingTimeSpan = postHeader.querySelector('.reading-time');
                if (readingTimeSpan) {
                    const originalText = readingTimeSpan.textContent.split(' / ')[0];
                    readingTimeSpan.textContent = `${originalText} / ${contentMinutesRounded} min audio`;
                }
            }
        }

        // Function to calculate reading time based on word count (English) and character count (Chinese)
        function calculateReadingTime(text) {
            if (!text || text.trim().length === 0) {
                return '1 min read';
            }

            // Remove HTML tags and get plain text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;
            const plainText = tempDiv.textContent || tempDiv.innerText || '';

            // Separate Chinese characters and English text
            const chineseCharRegex = /[\u4e00-\u9fff]/g;
            const chineseMatches = plainText.match(chineseCharRegex) || [];
            const chineseCharCount = chineseMatches.length;

            // Remove Chinese characters to count English words
            const englishText = plainText.replace(chineseCharRegex, ' ');
            const englishWords = englishText.trim().split(/\s+/).filter(word => word.length > 0 && /[a-zA-Z]/.test(word));
            const englishWordCount = englishWords.length;

            // Calculate reading time: English words / 250 + Chinese characters / 400
            const englishReadingTime = englishWordCount / 250;
            const chineseReadingTime = chineseCharCount / 400;
            const totalReadingTime = englishReadingTime + chineseReadingTime;
            const readingTimeMinutes = Math.ceil(totalReadingTime);

            // Return formatted reading time (minimum 1 minute)
            return `${Math.max(1, readingTimeMinutes)} min read`;
        }

        // Function to call Google Cloud Text-to-Speech API with text chunking for long content
        async function synthesizeSpeech(text, label = 'Audio') {
            // Detect language and choose appropriate voice
            const useChinese = containsChinese(text);
            const selectedVoice = useChinese ? GOOGLE_CLOUD_TTS_CONFIG.voice : GOOGLE_CLOUD_TTS_CONFIG.fallbackVoice;
            const logLabel = label.length > 30 ? label.substring(0, 30) + '...' : label;

            // Check IndexedDB cache first
            const cacheKey = await hashText(text + selectedVoice.languageCode + selectedVoice.ssmlGender);
            const cachedEntry = await AppCache.get(STORES.AUDIO, cacheKey);

            if (cachedEntry && cachedEntry.status === 'done') {
                console.log(`%c [${logLabel}] Using cached audio`, 'color: #4CAF50; font-weight: bold');
                return cachedEntry.data;
            } else if (cachedEntry && cachedEntry.status === 'in_progress') {
                console.log(`%c [${logLabel}] Previous synthesis incomplete, restarting...`, 'color: #FF9800');
            }

            // Mark as in-progress in cache
            await AppCache.set(STORES.AUDIO, cacheKey, { status: 'in_progress', data: null });

            // Check text length to determine approach
            const textBytes = new TextEncoder().encode(text).length;
            console.log(`[${logLabel}] Text bytes:`, textBytes);

            let result;
            if (textBytes <= GOOGLE_CLOUD_TTS_CONFIG.maxTextBytes) {
                console.log(`[${logLabel}] Single API call`);
                result = await synthesizeShortAudio(text, selectedVoice);
            } else {
                console.log(`[${logLabel}] Chunked synthesis`);
                result = await synthesizeChunkedAudio(text, selectedVoice, label);
            }

            // Save to cache if it's a small result
            if (typeof result === 'string') {
                await AppCache.set(STORES.AUDIO, cacheKey, { status: 'done', data: result });
                console.log(`%c [${logLabel}] Saved to cache`, 'color: #9E9E9E');
            }

            return result;
        }

        // Function for short audio synthesis (original API)
        async function synthesizeShortAudio(text, voice) {
            const requestBody = {
                input: { text: text },
                voice: voice,
                audioConfig: GOOGLE_CLOUD_TTS_CONFIG.audioConfig
            };

            try {
                const response = await fetch(`${GOOGLE_CLOUD_TTS_CONFIG.endpoint}?key=${GOOGLE_CLOUD_TTS_CONFIG.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Google Cloud TTS API error: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                return data.audioContent;
            } catch (error) {
                console.error('Short audio synthesis failed:', error);
                throw error;
            }
        }

        // Function for chunked audio synthesis (splits long text into smaller parts)
        async function synthesizeChunkedAudio(text, voice, label = 'Audio') {
            const logLabel = label.length > 30 ? label.substring(0, 30) + '...' : label;
            console.log(`[${logLabel}] Starting chunked synthesis`);

            // Split text into chunks with progressive sizes for faster first playback
            // First chunk: 1000 bytes, second: 2000 bytes, rest: maxTextBytes (4000)
            const chunks = splitTextIntoChunksProgressive(text, [1000, 2000, GOOGLE_CLOUD_TTS_CONFIG.maxTextBytes]);

            // Log chunk breakdown
            console.log(`%c [${logLabel}] Chunks: ${chunks.length} total`, 'font-weight: bold');
            chunks.forEach((chunk, i) => {
                const bytes = new TextEncoder().encode(chunk).length;
                console.log(`   [${logLabel}] Chunk ${i + 1}: ${bytes.toLocaleString()} bytes`);
            });

            // Synthesize first chunk immediately
            const firstChunkText = chunks[0].replace(/\./g, '');
            const firstChunkBytes = new TextEncoder().encode(firstChunkText).length;
            console.log(`%c [${logLabel}] Processing chunk 1/${chunks.length}`, 'color: #4CAF50', `(${firstChunkBytes.toLocaleString()} bytes)`);
            const startTime = performance.now();
            const firstChunk = await synthesizeShortAudio(firstChunkText, voice);
            const elapsed = (performance.now() - startTime).toFixed(0);
            console.log(`%c [${logLabel}] Chunk 1 ready`, 'color: #4CAF50', `${elapsed}ms`);

            // Create streaming audio result with first chunk and background processing
            const streamingResult = {
                firstChunk: firstChunk,
                totalChunks: chunks.length,
                currentChunkIndex: 0,
                chunks: chunks,
                voice: voice,
                audioQueue: [],
                isProcessing: true
            };

            // Assign cache key for saving later
            streamingResult.cacheKey = await hashText(text + voice.languageCode + voice.ssmlGender);

            // Process remaining chunks in background if there are more
            if (chunks.length > 1) {
                processRemainingChunks(streamingResult, chunks.slice(1), voice, label);
            } else {
                // Only one chunk, so firstChunk IS the merged content
                streamingResult.mergedContent = streamingResult.firstChunk;
                // Save single-chunk streaming result to cache
                if (streamingResult.cacheKey) {
                    await AppCache.set(STORES.AUDIO, streamingResult.cacheKey, { status: 'done', data: streamingResult });
                }
                streamingResult.isProcessing = false;
            }

            return streamingResult;
        }

        // Background processing of remaining chunks
        async function processRemainingChunks(streamingResult, remainingChunks, voice, label = 'Audio') {
            const logLabel = label.length > 30 ? label.substring(0, 30) + '...' : label;
            const totalStart = performance.now();

            for (let i = 0; i < remainingChunks.length; i++) {
                const chunkIndex = i + 1; // +1 because first chunk is already processed
                const chunkNum = chunkIndex + 1;
                const chunkBytes = new TextEncoder().encode(remainingChunks[i]).length;
                console.log(`%c [${logLabel}] Chunk ${chunkNum}/${streamingResult.totalChunks}`, 'color: #2196F3', `(${chunkBytes.toLocaleString()} bytes)`);

                try {
                    const startTime = performance.now();
                    // Replace periods with Chinese periods for better TTS pauses
                    const chunkText = remainingChunks[i].replace(/\./g, '');
                    const audioContent = await synthesizeShortAudio(chunkText, voice);
                    const elapsed = (performance.now() - startTime).toFixed(0);

                    streamingResult.audioQueue.push({
                        index: chunkIndex,
                        audioContent: audioContent,
                        text: remainingChunks[i]
                    });

                    console.log(`%c [${logLabel}] Chunk ${chunkNum} ready`, 'color: #2196F3', `${elapsed}ms`);

                    // Small delay between requests to avoid rate limiting
                    if (i < remainingChunks.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                } catch (error) {
                    console.error(`%c [${logLabel}] Chunk ${chunkNum} failed:`, 'color: #f44336', error.message);
                    // Continue processing other chunks even if one fails
                }
            }

            const totalElapsed = ((performance.now() - totalStart) / 1000).toFixed(1);

            // Merge all chunks once background processing is complete
            if (streamingResult.audioQueue.length === remainingChunks.length) {
                console.log(`%c [${logLabel}] Merging ${streamingResult.totalChunks} chunks...`, 'color: #9C27B0');
                const piecesToMerge = [streamingResult.firstChunk];

                // Ensure chunks are in correct order
                const sortedQueue = [...streamingResult.audioQueue].sort((a, b) => a.index - b.index);
                sortedQueue.forEach(q => piecesToMerge.push(q.audioContent));

                const merged = mergeBase64Audio(piecesToMerge);
                if (merged) {
                    streamingResult.mergedContent = merged;
                    console.log(`%c [${logLabel}] Merged into single file`, 'color: #4CAF50');
                }
            }

            // Save completed chunked synthesis to persistent cache FIRST
            // This ensures walkers see 'done' state before isProcessing is released
            if (streamingResult.cacheKey) {
                await AppCache.set(STORES.AUDIO, streamingResult.cacheKey, { status: 'done', data: streamingResult });
                console.log(`%c [${logLabel}] Saved to IndexedDB`, 'color: #9E9E9E');
            }

            streamingResult.isProcessing = false;
            console.log(`%c [${logLabel}] All ${streamingResult.totalChunks} chunks ready`, 'font-weight: bold; color: #4CAF50', `(total: ${totalElapsed}s)`);
        }

        // Function to split text into chunks with progressive byte limits
        // chunkSizes: array of max bytes for each chunk [first, second, ...rest]
        function splitTextIntoChunksProgressive(text, chunkSizes) {
            const chunks = [];
            const sentences = text.split(/[.!?]\s+/);
            let currentChunk = '';
            let chunkIndex = 0;

            function getMaxBytes() {
                // Use the last size for all chunks beyond the specified sizes
                return chunkSizes[Math.min(chunkIndex, chunkSizes.length - 1)];
            }

            for (const sentence of sentences) {
                const maxBytes = getMaxBytes();
                const testChunk = currentChunk + (currentChunk ? '. ' : '') + sentence;
                const testBytes = new TextEncoder().encode(testChunk).length;

                if (testBytes <= maxBytes) {
                    currentChunk = testChunk;
                } else {
                    // If current chunk has content, save it and start new chunk
                    if (currentChunk) {
                        chunks.push(currentChunk + '.');
                        chunkIndex++;
                        currentChunk = sentence;
                    } else {
                        // Single sentence is too long, split by words
                        const words = sentence.split(' ');
                        let wordChunk = '';

                        for (const word of words) {
                            const currentMaxBytes = getMaxBytes();
                            const testWordChunk = wordChunk + (wordChunk ? ' ' : '') + word;
                            const testWordBytes = new TextEncoder().encode(testWordChunk).length;

                            if (testWordBytes <= currentMaxBytes) {
                                wordChunk = testWordChunk;
                            } else {
                                if (wordChunk) {
                                    chunks.push(wordChunk);
                                    chunkIndex++;
                                    wordChunk = word;
                                } else {
                                    // Single word is too long, truncate it
                                    chunks.push(word.substring(0, currentMaxBytes / 4)); // Rough estimate
                                    chunkIndex++;
                                    wordChunk = '';
                                }
                            }
                        }

                        if (wordChunk) {
                            currentChunk = wordChunk;
                        }
                    }
                }
            }

            // Add the last chunk if it has content
            if (currentChunk) {
                chunks.push(currentChunk + '.');
            }

            return chunks.filter(chunk => chunk.trim().length > 0);
        }

        // Audio queue manager for streaming playback
        class AudioQueueManager {
            constructor(streamingResult, button, contentDiv) {
                this.streamingResult = streamingResult;
                this.button = button;
                this.contentDiv = contentDiv;
                this.currentAudio = null;
                this.currentChunkIndex = 0;
                this.isPlaying = false;
                this.isPaused = false;
                this.isDestroyed = false;
                this.chunkStartTime = null;
                this.totalPlayTime = 0;
                this.lastSegmentIndex = -1;

                // Calculate character ranges for each chunk for text tracking
                this.chunkCharRanges = this.calculateChunkCharRanges();
            }

            // Calculate character start/end positions for each audio chunk
            calculateChunkCharRanges() {
                const ranges = [];
                let charOffset = 0;

                for (let i = 0; i < this.streamingResult.chunks.length; i++) {
                    const chunkText = this.streamingResult.chunks[i];
                    const charLength = chunkText.length;
                    ranges.push({
                        start: charOffset,
                        end: charOffset + charLength
                    });
                    charOffset += charLength;
                }

                return ranges;
            }

            // Set up text tracking for current audio
            setupTextTracking(audio) {
                if (!this.contentDiv || !this.contentDiv._totalChars) return;

                const chunkRange = this.chunkCharRanges[this.currentChunkIndex];
                if (!chunkRange) return;

                audio.ontimeupdate = () => {
                    if (this.isDestroyed || !audio.duration) return;

                    // Calculate position within this chunk
                    const chunkProgress = audio.currentTime / audio.duration;
                    const chunkCharLength = chunkRange.end - chunkRange.start;
                    const charPosInChunk = Math.floor(chunkProgress * chunkCharLength);
                    const globalCharPos = chunkRange.start + charPosInChunk;

                    const segmentIndex = findSegmentByCharPosition(this.contentDiv, globalCharPos);
                    if (segmentIndex !== this.lastSegmentIndex) {
                        this.lastSegmentIndex = segmentIndex;
                        highlightSegment(this.contentDiv, segmentIndex);
                    }
                };
            }

            async playFirstChunk() {
                if (this.isDestroyed) return;

                const chunkBytes = new TextEncoder().encode(this.streamingResult.chunks[0]).length;
                console.log(`%c Playing chunk 1/${this.streamingResult.totalChunks}`, 'color: #9C27B0', `(${chunkBytes.toLocaleString()} bytes)`);
                this.chunkStartTime = performance.now();

                // Use shared audio player
                const audio = getSharedAudio();
                audio.src = `data:audio/mpeg;base64,${this.streamingResult.firstChunk}`;
                audio.playbackRate = window.currentPlaybackSpeed || 1.0;

                this.currentAudio = audio;
                this.currentChunkIndex = 0;

                // Set up event handlers
                audio.onended = () => this.onChunkEnded();
                audio.onerror = (e) => this.onAudioError(e);

                // Set up text tracking
                this.setupTextTracking(audio);

                try {
                    await audio.play();
                } catch (playError) {
                    if (playError.name === 'NotAllowedError') {
                        throw new Error('Autoplay blocked. Please click the play button manually.');
                    }
                    throw playError;
                }
                this.isPlaying = true;
                this.isPaused = false;
            }

            async onChunkEnded() {
                if (this.isDestroyed) return;

                const playDuration = ((performance.now() - this.chunkStartTime) / 1000).toFixed(1);
                this.totalPlayTime += parseFloat(playDuration);
                console.log(`%c Chunk ${this.currentChunkIndex + 1} ended`, 'color: #607D8B', `(played ${playDuration}s)`);

                // Check if there are more chunks to play
                if (this.currentChunkIndex + 1 < this.streamingResult.totalChunks) {
                    await this.playNextChunk();
                } else {
                    // All chunks finished
                    console.log('All chunks finished playing');
                    this.onAllChunksFinished();
                }
            }

            async playNextChunk() {
                if (this.isDestroyed) return;

                const nextChunkIndex = this.currentChunkIndex + 1;

                // Find the next chunk in the queue
                const nextChunk = this.streamingResult.audioQueue.find(chunk => chunk.index === nextChunkIndex);

                if (nextChunk) {
                    const chunkBytes = new TextEncoder().encode(nextChunk.text).length;
                    console.log(`%c Playing chunk ${nextChunkIndex + 1}/${this.streamingResult.totalChunks}`, 'color: #9C27B0', `(${chunkBytes.toLocaleString()} bytes)`);
                    this.chunkStartTime = performance.now();

                    // Use shared player
                    const audio = getSharedAudio();
                    audio.src = `data:audio/mpeg;base64,${nextChunk.audioContent}`;
                    audio.playbackRate = window.currentPlaybackSpeed || 1.0;

                    this.currentAudio = audio;
                    this.currentChunkIndex = nextChunkIndex;

                    audio.onended = () => this.onChunkEnded();
                    audio.onerror = (e) => this.onAudioError(e);

                    // Set up text tracking for this chunk
                    this.setupTextTracking(audio);

                    try {
                        await audio.play();
                    } catch (playError) {
                        console.error('Next chunk playback failed:', playError);
                        // Likely a permission issue after a long chunk, show error
                        if (playError.name === 'NotAllowedError') {
                            alert('Playback was interrupted by your browser. Please click the resume button.');
                        }
                    }
                } else {
                    // Chunk not ready yet, wait and retry
                    console.log(`%c Chunk ${nextChunkIndex + 1} not ready, waiting...`, 'color: #FF9800');
                    setTimeout(() => this.playNextChunk(), 500);
                }
            }

            pause() {
                if (this.currentAudio && this.isPlaying) {
                    this.currentAudio.pause();
                    this.isPlaying = false;
                    this.isPaused = true;
                    console.log(`%c Paused at chunk ${this.currentChunkIndex + 1}/${this.streamingResult.totalChunks}`, 'color: #FF9800');
                    updateMediaSession(this.button);
                }
            }

            async resume() {
                if (this.currentAudio && this.isPaused) {
                    try {
                        await this.currentAudio.play();
                        this.isPlaying = true;
                        this.isPaused = false;
                        console.log(`%c Resumed chunk ${this.currentChunkIndex + 1}/${this.streamingResult.totalChunks}`, 'color: #4CAF50');
                        updateMediaSession(this.button);
                    } catch (e) {
                        console.error('Resume failed:', e);
                    }
                }
            }

            stop() {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                }
                this.isPlaying = false;
                this.isPaused = false;
                this.isDestroyed = true;
                // Clear text tracking highlights
                clearTextTracking(this.contentDiv);
                console.log(`%c Audio stopped`, 'color: #f44336');
            }

            onAudioError(e) {
                console.error(`%c Audio error in chunk ${this.currentChunkIndex + 1}:`, 'color: #f44336', e);
                this.onAllChunksFinished();
            }

            onAllChunksFinished() {
                console.log(`%c Playback complete (${this.streamingResult.totalChunks} chunks)`, 'font-weight: bold; color: #4CAF50', `(total: ${this.totalPlayTime.toFixed(1)}s)`);
                // Update header with audio minutes
                updateAudioMinutes(this.button, this.totalPlayTime);

                // Clear text tracking highlights
                clearTextTracking(this.contentDiv);
                resetButton(this.button);
                this.isDestroyed = true;
                updateFloatingMarkState();
                // Auto mark as read when audio finishes
                autoMarkPostAsRead(this.button);
                // Auto play next post if continuous play is enabled
                autoContinuousPlay(this.button);
            }
        }

        function stopAllOtherAudio(currentButton) {
            // Find all listen buttons and stop their audio
            const allListenButtons = document.querySelectorAll('.listen-btn');
            allListenButtons.forEach(button => {
                if (button !== currentButton && button.speechState && (button.speechState.isPlaying || button.speechState.isPaused)) {
                    // Clear text tracking for this button's content
                    if (button.speechState.contentDiv) {
                        clearTextTracking(button.speechState.contentDiv);
                    }
                    // Stop streaming audio if present
                    if (button.speechState.audioQueueManager) {
                        button.speechState.audioQueueManager.stop();
                    }
                    // Stop single audio if present
                    if (button.speechState.audio) {
                        button.speechState.audio.pause();
                    }
                    resetButton(button);
                }
            });

            // Stop shared audio player if it belongs to someone else
            if (window.sharedAudio && !window.sharedAudio.paused) {
                 window.sharedAudio.pause();
            }

            // Stop all YouTube videos
            const allIframes = document.querySelectorAll('iframe');
            allIframes.forEach(iframe => {
                try {
                    iframe.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');
                } catch (e) {}
            });
        }

        function stopAllPlayback() {
            console.log('Stopping all media playback...');
            stopAllOtherAudio(null);
            if (window.sharedAudio) {
                window.sharedAudio.pause();
                // We don't clear .src here to allow resumes if needed,
                // but for a "totally clean state", we ensure all buttons are reset.
            }
        }

        function resetButton(button) {
            if (button.speechState) {
                // Clear text tracking highlights
                if (button.speechState.contentDiv) {
                    clearTextTracking(button.speechState.contentDiv);
                    button.speechState.contentDiv = null;
                }
                // Clean up streaming audio if present
                if (button.speechState.audioQueueManager) {
                    button.speechState.audioQueueManager.stop();
                    button.speechState.audioQueueManager = null;
                }
                // Clean up single audio if present
                if (button.speechState.audio) {
                    button.speechState.audio.pause();
                    button.speechState.audio = null;
                }
                button.speechState.isPlaying = false;
                button.speechState.isPaused = false;
            }

            if (window.currentAudioButton === button) {
                window.currentAudioButton = null;
                updateMediaSession(null);
            }

            button.classList.remove('playing', 'loading', 'paused');
            button.innerHTML = `
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <polygon points="5,3 19,12 5,21" stroke="currentColor" stroke-width="2" fill="none"/>
                </svg>
            `;
        }

        // Online/offline event listeners
        function setupOfflineSupport() {
            // Update online status
            window.addEventListener('online', function() {
                isOnline = true;
                console.log('Back online - processing queued actions');
                showSyncNotification('Back online! Syncing...');
                setTimeout(processOfflineQueue, 1000); // Small delay to ensure connection is stable
            });

            window.addEventListener('offline', function() {
                isOnline = false;
                console.log('Gone offline - actions will be queued');
                // Only show offline notification if there are pending tasks
                if (offlineQueue.length > 0) {
                    showOfflineNotification('You\'re offline. Actions will be saved and synced later.');
                }
            });

            // Process any existing queue on page load if online
            if (isOnline && offlineQueue.length > 0) {
                console.log('Found queued actions from previous session');
                setTimeout(processOfflineQueue, 2000); // Delay to let page fully load
            }

            // Show offline indicator if currently offline and there are pending tasks
            if (!isOnline && offlineQueue.length > 0) {
                showOfflineNotification('You\'re currently offline. Actions will be saved and synced later.');
            }
        }

        // Hamburger menu functionality
        function setupHamburgerMenu() {
            const headerMenuBtn = document.getElementById('header-menu');
            const menuOverlay = document.getElementById('menu-overlay');
            const menuSidebar = document.getElementById('menu-sidebar');
            const menuClose = document.getElementById('menu-close');
            const themeToggle = document.getElementById('theme-toggle');
            const themeToggleItem = document.getElementById('theme-toggle-item');
            const syncMenuItem = document.getElementById('sync-menu-item');
            const appConfigMenuItem = document.getElementById('app-config-menu-item');

            // Load saved theme - default to dark
            const savedTheme = localStorage.getItem('learner_theme') || 'dark';
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                themeToggle.classList.add('dark');
            }

            // Menu controls
            const openMenu = () => { menuOverlay.classList.add('active'); menuSidebar.classList.add('active'); };
            const closeMenu = () => { menuOverlay.classList.remove('active'); menuSidebar.classList.remove('active'); };

            headerMenuBtn.addEventListener('click', openMenu);
            menuClose.addEventListener('click', closeMenu);
            menuOverlay.addEventListener('click', closeMenu);

            // Theme toggle
            themeToggleItem.addEventListener('click', () => {
                const isDark = document.body.classList.contains('dark-mode');
                document.body.classList.toggle('dark-mode', !isDark);
                themeToggle.classList.toggle('dark', !isDark);
                localStorage.setItem('learner_theme', isDark ? 'light' : 'dark');
            });

            appConfigMenuItem.addEventListener('click', () => {
                closeMenu();
                showUnifiedSettingsModal();
            });

            // Clear Audio Cache
            document.getElementById('clear-audio-item').addEventListener('click', async () => {
                if (confirm('Are you sure you want to clear all cached audio? This will require re-syncing for offline use.')) {
                    closeMenu();
                    const notification = showSyncNotification('Clearing audio cache...', 0);
                    try {
                        await AppCache.clear(STORES.AUDIO);
                        notification.textContent = 'Audio cache cleared successfully';
                        updateSyncStatusDisplay();
                        setTimeout(() => {
                            notification.classList.remove('show');
                            setTimeout(() => notification.remove(), 300);
                        }, 2000);
                    } catch (e) {
                        console.error('Failed to clear audio cache:', e);
                        notification.textContent = 'Failed to clear audio cache';
                        setTimeout(() => {
                            notification.classList.remove('show');
                            setTimeout(() => notification.remove(), 300);
                        }, 3000);
                    }
                }
            });

            // Font size controls
            const fontSizeDecrease = document.getElementById('font-size-decrease');
            const fontSizeIncrease = document.getElementById('font-size-increase');
            const fontSizeDisplay = document.getElementById('font-size-display');

            // Load saved font scale - default to 1
            let fontScale = parseFloat(localStorage.getItem('learner_font_scale')) || 1;
            updateFontScale(fontScale);

            function updateFontScale(scale) {
                fontScale = Math.max(0.8, Math.min(1.5, scale)); // Limit between 80% and 150%
                document.documentElement.style.setProperty('--font-scale', fontScale);
                fontSizeDisplay.textContent = Math.round(fontScale * 100) + '%';
                localStorage.setItem('learner_font_scale', fontScale);
            }

            fontSizeDecrease.addEventListener('click', () => updateFontScale(fontScale - 0.1));
            fontSizeIncrease.addEventListener('click', () => updateFontScale(fontScale + 0.1));

            // Playback speed controls
            const playbackSpeedDecrease = document.getElementById('playback-speed-decrease');
            const playbackSpeedIncrease = document.getElementById('playback-speed-increase');
            const playbackSpeedDisplay = document.getElementById('playback-speed-display');

            // Playback speed options: 1.0, 1.25, 1.5, 2.0
            const playbackSpeeds = [1.0, 1.25, 1.5, 2.0];
            let currentSpeedIndex = parseInt(localStorage.getItem('learner_playback_speed_index')) || 0;
            updatePlaybackSpeed(currentSpeedIndex);

            function updatePlaybackSpeed(speedIndex) {
                currentSpeedIndex = Math.max(0, Math.min(playbackSpeeds.length - 1, speedIndex));
                const speed = playbackSpeeds[currentSpeedIndex];
                playbackSpeedDisplay.textContent = speed + 'x';
                localStorage.setItem('learner_playback_speed_index', currentSpeedIndex);

                // Update global playback speed variable for audio elements
                window.currentPlaybackSpeed = speed;
            }

            playbackSpeedDecrease.addEventListener('click', () => updatePlaybackSpeed(currentSpeedIndex - 1));
            playbackSpeedIncrease.addEventListener('click', () => updatePlaybackSpeed(currentSpeedIndex + 1));

            // Auto Mark Read toggle
            const autoMarkReadToggle = document.getElementById('auto-mark-read-toggle');
            const autoMarkReadItem = document.getElementById('auto-mark-read-item');

            // Load saved setting - default to true (on)
            window.autoMarkReadEnabled = localStorage.getItem('learner_auto_mark_read') !== 'false';
            if (window.autoMarkReadEnabled) {
                autoMarkReadToggle.classList.add('dark');
            }

            autoMarkReadItem.addEventListener('click', () => {
                window.autoMarkReadEnabled = !window.autoMarkReadEnabled;
                autoMarkReadToggle.classList.toggle('dark', window.autoMarkReadEnabled);
                localStorage.setItem('learner_auto_mark_read', window.autoMarkReadEnabled);
            });

            // Continuous Play toggle
            const continuousPlayToggle = document.getElementById('continuous-play-toggle');
            const continuousPlayItem = document.getElementById('continuous-play-item');

            // Load saved setting - default to true (on) - UPDATED
            window.continuousPlayEnabled = localStorage.getItem('learner_continuous_play') !== 'false';
            if (window.continuousPlayEnabled) {
                continuousPlayToggle.classList.add('dark');
            }

            continuousPlayItem.addEventListener('click', () => {
                window.continuousPlayEnabled = !window.continuousPlayEnabled;
                continuousPlayToggle.classList.toggle('dark', window.continuousPlayEnabled);
                localStorage.setItem('learner_continuous_play', window.continuousPlayEnabled);
            });

            // Auto Preload toggle
            const autoPreloadToggle = document.getElementById('auto-preload-toggle');
            const autoPreloadItem = document.getElementById('auto-preload-item');

            // Setting already loaded in loadPosts() or DOMContentLoaded
            if (window.autoPreloadEnabled) {
                autoPreloadToggle.classList.add('dark');
            }

            autoPreloadItem.addEventListener('click', () => {
                window.autoPreloadEnabled = !window.autoPreloadEnabled;
                autoPreloadToggle.classList.toggle('dark', window.autoPreloadEnabled);
                localStorage.setItem('learner_auto_preload', window.autoPreloadEnabled);
            });
        }

        // App Configuration Functions
        function updateAppConfigStatus() {
            const statusIndicator = document.getElementById('app-config-status');
            const apiKey = localStorage.getItem('googleCloudTTSApiKey');
            const webhook = localStorage.getItem('learner_webhook_base_url');
            const sheetId = localStorage.getItem('learner_sheet_id');

            if (apiKey && webhook && sheetId) {
                statusIndicator.classList.add('configured');
                statusIndicator.title = 'App fully configured';
            } else if (apiKey || webhook || sheetId) {
                statusIndicator.classList.add('configured');
                statusIndicator.style.opacity = '0.5';
                statusIndicator.title = 'App partially configured';
            } else {
                statusIndicator.classList.remove('configured');
                statusIndicator.title = 'App not configured';
            }
        }

        function showUnifiedSettingsModal() {
            const modal = document.getElementById('unified-settings-modal');

            // Populate fields from localStorage
            document.getElementById('unified-api-key-input').value = localStorage.getItem('googleCloudTTSApiKey') || '';
            document.getElementById('unified-webhook-input').value = localStorage.getItem('learner_webhook_base_url') || '';
            document.getElementById('unified-sheet-id-input').value = localStorage.getItem('learner_sheet_id') || '';
            document.getElementById('unified-videos-gid-input').value = localStorage.getItem('learner_videos_gid') || '';

            modal.classList.add('show');
            setTimeout(() => document.getElementById('unified-api-key-input').focus(), 100);
        }

        function hideUnifiedSettingsModal() {
            document.getElementById('unified-settings-modal').classList.remove('show');
        }


        function saveUnifiedSettings() {
            const apiKey = document.getElementById('unified-api-key-input').value.trim();
            const webhookUrl = document.getElementById('unified-webhook-input').value.trim();
            const sheetId = document.getElementById('unified-sheet-id-input').value.trim();
            const videosGid = document.getElementById('unified-videos-gid-input').value.trim();

            if (apiKey) localStorage.setItem('googleCloudTTSApiKey', apiKey);
            else localStorage.removeItem('googleCloudTTSApiKey');

            if (webhookUrl) {
                let url = webhookUrl;
                if (!url.startsWith('http')) url = 'https://' + url;
                if (!url.endsWith('/')) url += '/';
                localStorage.setItem('learner_webhook_base_url', url);
            } else {
                localStorage.removeItem('learner_webhook_base_url');
            }

            if (sheetId) localStorage.setItem('learner_sheet_id', sheetId);
            else localStorage.removeItem('learner_sheet_id');

            if (videosGid) localStorage.setItem('learner_videos_gid', videosGid);
            else localStorage.removeItem('learner_videos_gid');

            updateAppConfigStatus();
            hideUnifiedSettingsModal();

            if (confirm('Settings saved. Reload page now to apply changes?')) {
                window.location.reload();
            }
        }

        function setupUnifiedSettingsModal() {
            const modal = document.getElementById('unified-settings-modal');
            const closeBtn = document.getElementById('unified-settings-close');
            const cancelBtn = document.getElementById('unified-settings-cancel');
            const form = document.getElementById('unified-settings-form');
            const copyBulkBtn = document.getElementById('copy-bulk-config');
            const applyBulkBtn = document.getElementById('apply-bulk-config');

            closeBtn.addEventListener('click', hideUnifiedSettingsModal);
            cancelBtn.addEventListener('click', hideUnifiedSettingsModal);

            modal.addEventListener('click', (e) => {
                if (e.target === modal) hideUnifiedSettingsModal();
            });

            form.addEventListener('submit', (e) => {
                e.preventDefault();
                saveUnifiedSettings();
            });

            copyBulkBtn.addEventListener('click', () => {
                const config = {
                    tts_api_key: localStorage.getItem('googleCloudTTSApiKey') || '',
                    webhook_url: localStorage.getItem('learner_webhook_base_url') || '',
                    sheet_id: localStorage.getItem('learner_sheet_id') || '',
                    videos_gid: localStorage.getItem('learner_videos_gid') || ''
                };
                const json = JSON.stringify(config, null, 2);
                navigator.clipboard.writeText(json).then(() => {
                    const originalText = copyBulkBtn.textContent;
                    copyBulkBtn.textContent = 'Copied!';
                    setTimeout(() => copyBulkBtn.textContent = originalText, 2000);
                });
            });

            applyBulkBtn.addEventListener('click', async () => {
                try {
                    const text = await navigator.clipboard.readText();
                    const config = JSON.parse(text);

                    if (config.tts_api_key !== undefined) localStorage.setItem('googleCloudTTSApiKey', config.tts_api_key);
                    if (config.webhook_url !== undefined) localStorage.setItem('learner_webhook_base_url', config.webhook_url);
                    if (config.sheet_id !== undefined) localStorage.setItem('learner_sheet_id', config.sheet_id);
                    if (config.videos_gid !== undefined) localStorage.setItem('learner_videos_gid', config.videos_gid);

                    alert('Configuration applied successfully! Reloading...');
                    window.location.reload();
                } catch (e) {
                    alert('Failed to apply config. Please ensure you have a valid JSON object in your clipboard. Error: ' + e.message);
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal.classList.contains('show')) {
                    hideUnifiedSettingsModal();
                }
            });

            updateAppConfigStatus();
        }

        function copyToClipboard(elementId) {
            const input = document.getElementById(elementId);
            if (!input || !input.value) return;

            navigator.clipboard.writeText(input.value).then(() => {
                // Find the button next to the input
                const btn = input.nextElementSibling;
                if (btn && btn.classList.contains('copy-btn')) {
                    const originalHTML = btn.innerHTML;
                    btn.innerHTML = `
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" color="green">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                    `;
                    setTimeout(() => {
                        btn.innerHTML = originalHTML;
                    }, 2000);
                }
            });
        }

        // Load posts when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Ensure any existing audio is stopped on refresh
            stopAllPlayback();

            // Initialize global playback speed
            const playbackSpeeds = [1.0, 1.25, 1.5, 2.0];
            const savedSpeedIndex = parseInt(localStorage.getItem('learner_playback_speed_index')) || 0;
            window.currentPlaybackSpeed = playbackSpeeds[savedSpeedIndex] || 1.0;

            setupOfflineSupport();
            setupHeaderAudioButton();
            loadPosts().then(() => {

                setupCollapseAll();
                setupTextHighlighting();
                setupHeaderTitleUpdate();
                setupHamburgerMenu();
                setupUnifiedSettingsModal();
                setupBottomTabs();
                setupBottomTabsScrollBehavior();
                setupFloatingNav();
            });
        });

        // Setup header audio button click handler
        function setupHeaderAudioButton() {
            const headerBtn = document.getElementById('header-audio-btn');
            if (!headerBtn) return;

            headerBtn.addEventListener('click', function(e) {
                e.stopPropagation();

                const currentPost = headerBtn._currentPost || getPostUnderHeader();
                if (currentPost) {
                    const markBtn = currentPost.querySelector('.mark-read-btn-bottom');
                    if (markBtn) {
                        markBtn.click();
                        updateHeaderAudioControl();
                    }
                }
            });
        }

        // Bottom Tab Navigation Setup
        function setupBottomTabs() {
            const tabItems = document.querySelectorAll('.tab-item');

            tabItems.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Get tab type
                    const tabType = tab.dataset.tab;

                    // Check if clicking on already active tab
                    const isAlreadyActive = tab.classList.contains('active');

                    if (isAlreadyActive) {
                        // Scroll to top if clicking on active tab
                        window.scrollTo({
                            top: 0,
                            behavior: 'smooth'
                        });
                        refreshTab(tabType);
                        return;
                    }

                    // Remove active class from all tabs
                    tabItems.forEach(t => t.classList.remove('active'));

                    // Add active class to clicked tab
                    tab.classList.add('active');

                    // Handle tab switching logic
                    handleTabSwitch(tabType);
                });
            });
        }

        // Bottom Tabs Scroll Behavior
        function setupBottomTabsScrollBehavior() {
            const bottomTabs = document.querySelector('.bottom-tabs');
            if (!bottomTabs) return;
            let lastScrollTop = 0;
            let scrollTimeout;
            let lastScrollDirection = null;
            const scrollThreshold = 5; // Minimum pixels to consider as intentional scroll

            window.addEventListener('scroll', () => {
                const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const scrollDifference = Math.abs(currentScrollTop - lastScrollTop);

                // Clear existing timeout
                clearTimeout(scrollTimeout);

                // Only process scroll if it's above threshold (prevents jitter)
                if (scrollDifference > scrollThreshold) {
                    // Determine scroll direction
                    if (currentScrollTop > lastScrollTop && currentScrollTop > 100) {
                        // Scrolling down - hide tabs
                        bottomTabs.classList.add('hidden');
                        lastScrollDirection = 'down';
                    } else if (currentScrollTop < lastScrollTop) {
                        // Scrolling up - show tabs
                        bottomTabs.classList.remove('hidden');
                        lastScrollDirection = 'up';
                    }

                    lastScrollTop = currentScrollTop <= 0 ? 0 : currentScrollTop;
                }

                // Only show tabs after scroll stops if:
                // 1. User was scrolling up, OR
                // 2. User is near the top of the page
                scrollTimeout = setTimeout(() => {
                    if (lastScrollDirection === 'up' || currentScrollTop < 200) {
                        bottomTabs.classList.remove('hidden');
                    }
                }, 1000);
            }, { passive: true });
        }

        async function handleTabSwitch(tabType) {
            // Don't switch if already on the same tab
            if (currentTab === tabType) return;

            console.log('Switched to tab:', tabType);

            // Stop all playback when switching tabs
            stopAllPlayback();

            // Update current tab
            currentTab = tabType;

            // Update tab button states
            document.querySelectorAll('.tab-item').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`tab-${tabType}`).classList.add('active');

            // Hide all tab content containers
            document.querySelectorAll('.tab-content').forEach(container => {
                container.style.display = 'none';
            });

            // Show the selected tab container
            const targetContainer = document.getElementById(`${tabType}-container`);
            targetContainer.style.display = 'block';

            // Load content for the tab if not already loaded
            await renderTabContent(tabType);

            // Reset header title when switching tabs
            resetHeaderTitle();

            // Trigger floating nav visibility update
            window.dispatchEvent(new Event('resize'));
        }

        async function refreshTab(tabType) {
            console.log('Refreshing tab:', tabType);
            if (!isOnline) {
                console.warn('Offline - skipping refresh');
                showOfflineNotification('You\'re offline. Showing cached content.');
                showSyncNotification('Failed');
                return;
            }

            cachedData[tabType] = null;

            const container = document.getElementById(`${tabType}-container`);
            if (container) {
                // Stop all playback before clearing content to avoid orphaned audio
                stopAllPlayback();
                container.innerHTML = '';
            }

            try {
                await loadTabData(tabType);

                const noPostsElement = document.getElementById('no-posts');
                if (noPostsElement) {
                    noPostsElement.style.display = 'none';
                }

                await renderTabContent(tabType);

                if (currentTab === tabType) {
                    resetHeaderTitle();
                    showSyncNotification('Synced');
                }
            } catch (error) {
                console.error(`Error refreshing ${tabType}:`, error);
                showSyncNotification('Failed');
            }
        }
    </script>


    <!-- Bottom Tab Navigation -->
    <div class="bottom-tabs">
        <button class="tab-item active" id="tab-videos" data-tab="videos">
            <svg class="tab-icon" viewBox="0 0 24 24">
                <polygon points="23 7 16 12 23 17 23 7"></polygon>
                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
            </svg>
            <span class="tab-label">Videos</span>
        </button>
    </div>
</body>
</html>